{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to LearnD3D11 \u00b6 Goal \u00b6 Explain the goal","title":"Welcome to LearnD3D11"},{"location":"#welcome-to-learnd3d11","text":"","title":"Welcome to LearnD3D11"},{"location":"#goal","text":"Explain the goal","title":"Goal"},{"location":"about/","text":"About Learn D3D11 \u00b6 Disclaimer \u00b6 We are just a bunch of graphics programming enthusiasts doing all this on our own time. If you find typos, bugs or have questions, dont hesitate to open an issue or even send a PR, otherwise join us on our discord server Join Graphics Programming","title":"About"},{"location":"about/#about-learn-d3d11","text":"","title":"About Learn D3D11"},{"location":"about/#disclaimer","text":"We are just a bunch of graphics programming enthusiasts doing all this on our own time. If you find typos, bugs or have questions, dont hesitate to open an issue or even send a PR, otherwise join us on our discord server Join Graphics Programming","title":"Disclaimer"},{"location":"license/","text":"MIT License Copyright (c) 2022 Graphics Programming Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"1-introduction/1-1-getting-started/1-1-0-overview/","text":"Overview \u00b6 As many may know or not know, there's a few choices in terms of what to use for graphics, such as OpenGL, Vulkan, Metal and what is commonly known as \"DirectX\". However in word of mouth DirectX usually refers to Direct3D, which is one of the many API's that DirectX has, as it is less known that DirectX is more than just graphics, it is: Audio Fonts Input Graphics And other things more or less targeted at stuff one needs for game development. The goal of LearnD3D11 is as one might guess is the targeted explanation and showcase of Direct3D11 or as one generally refers to it: \"DirectX 11\". During each step we'll provide a project for you to follow along as we explain each individual thing needed to get some graphics on your own screen. This initial section will cover creating the actual window, initializing Direct3D11 and getting our very first visuals (which is commonly known as the Hello Triangle) Project structure \u00b6 A few words about how each project will look like. Inside the project folder: Assets/ Assets/Models/ Assets/Shaders/ Assets/Textures/ bin/Debug/ bin/Release/ obj/Debug/ obj/Release/ Main.cpp x-x-x-project.vcxproj.filters x-x-x-project.vcxproj.user x-x-x-project.vcxproj The vcxproj files are part of Visual Studio's project system. Main.cpp is the entry point of each application. (in the first few chapters we will have all the code in there, but later refactor them out into their own units) obj/ contains all intermediate junk the compiler produced, to keep the folder structure clean bin/ will contain the compiled program of the chapter along with all necessary Assets Assets/ will contain all the used assets, such as models, shaders and textures and other things. It will be empty for the first few chapters, and we will copy it and its contents to the bin/Debug or bin/Release directory, depending on which configuration you chose Next chapter","title":"Overview"},{"location":"1-introduction/1-1-getting-started/1-1-0-overview/#overview","text":"As many may know or not know, there's a few choices in terms of what to use for graphics, such as OpenGL, Vulkan, Metal and what is commonly known as \"DirectX\". However in word of mouth DirectX usually refers to Direct3D, which is one of the many API's that DirectX has, as it is less known that DirectX is more than just graphics, it is: Audio Fonts Input Graphics And other things more or less targeted at stuff one needs for game development. The goal of LearnD3D11 is as one might guess is the targeted explanation and showcase of Direct3D11 or as one generally refers to it: \"DirectX 11\". During each step we'll provide a project for you to follow along as we explain each individual thing needed to get some graphics on your own screen. This initial section will cover creating the actual window, initializing Direct3D11 and getting our very first visuals (which is commonly known as the Hello Triangle)","title":"Overview"},{"location":"1-introduction/1-1-getting-started/1-1-0-overview/#project-structure","text":"A few words about how each project will look like. Inside the project folder: Assets/ Assets/Models/ Assets/Shaders/ Assets/Textures/ bin/Debug/ bin/Release/ obj/Debug/ obj/Release/ Main.cpp x-x-x-project.vcxproj.filters x-x-x-project.vcxproj.user x-x-x-project.vcxproj The vcxproj files are part of Visual Studio's project system. Main.cpp is the entry point of each application. (in the first few chapters we will have all the code in there, but later refactor them out into their own units) obj/ contains all intermediate junk the compiler produced, to keep the folder structure clean bin/ will contain the compiled program of the chapter along with all necessary Assets Assets/ will contain all the used assets, such as models, shaders and textures and other things. It will be empty for the first few chapters, and we will copy it and its contents to the bin/Debug or bin/Release directory, depending on which configuration you chose Next chapter","title":"Project structure"},{"location":"1-introduction/1-1-getting-started/1-1-1-hello-window/","text":"Hello Window \u00b6 Note If you want to try to follow this series without downloading the full source, you can try this empty project, it has been setup already with all the include directories and libraries you will need throughout the whole series! Link to the full source code Let's start with the whole example code for creating a simple window first. We use the GLFW library to create our window and as you can probably see, it's really not that much code. The following code opens a new blank window titled \"LearnD3D11 - Hello Window\" and will leave it open until you hit close. #include <GLFW/glfw3.h> #include <cstdint> #include <iostream> int main ( int argc , char * argv []) { if ( ! glfwInit ()) { std :: cout << \"GLFW: Unable to initialize \\n \" ; return -1 ; } GLFWmonitor * primaryMonitor = glfwGetPrimaryMonitor (); const GLFWvidmode * videoMode = glfwGetVideoMode ( primaryMonitor ); const int32_t width = static_cast < int32_t > ( videoMode -> width * 0.9f ); const int32_t height = static_cast < int32_t > ( videoMode -> height * 0.9f ); glfwWindowHint ( GLFW_SCALE_TO_MONITOR , GLFW_FALSE ); glfwWindowHint ( GLFW_CLIENT_API , GLFW_NO_API ); GLFWwindow * window = glfwCreateWindow ( width , height , \"LearnD3D11 - Hello Window\" , nullptr , nullptr ); if ( window == nullptr ) { std :: cout << \"GLFW: Unable to create window \\n \" ; glfwTerminate (); return -1 ; } const int32_t windowLeft = videoMode -> width / 2 - width / 2 ; const int32_t windowTop = videoMode -> height / 2 - height / 2 ; glfwSetWindowPos ( window , windowLeft , windowTop ); while ( ! glfwWindowShouldClose ( window )) { glfwPollEvents (); // future update code // future render code } glfwDestroyWindow ( window ); glfwTerminate (); return 0 ; } Now let's go over everything in that example in more detail. #include <GLFW/glfw3.h> C++ needs to know where all the definitions and declarations are coming from. We therefore have to include the GLFW header so that everything we need is present in our source file. if ( ! glfwInit ()) { std :: cout << \"GLFW: Unable to initialize \\n \" ; return -1 ; } Pretty obvious, right? glfwInit tries to initialize GLFW . If it fails to do so, let the user know and end the program, since there is no point in going further. GLFWmonitor * primaryMonitor = glfwGetPrimaryMonitor (); const GLFWvidmode * videoMode = glfwGetVideoMode ( primaryMonitor ); const int32_t width = static_cast < int32_t > ( videoMode -> width * 0.9f ); const int32_t height = static_cast < int32_t > ( videoMode -> height * 0.9f ); This piece of code grabs the main monitor via glfwGetPrimaryMonitor and its current resolution with glfwGetVideoMode , so that we can derive a window width and height from it - and it will look similar no matter what resolution you use. Size-wise it will cover 90% of your main monitor. glfwWindowHint ( GLFW_SCALE_TO_MONITOR , GLFW_FALSE ); This will tell GLFW to not scale the window in any way, should you have setup a specific scaling other than 100% on your desktop. That will keep the windowsize at what we set it, without thinking about odd fractionals to manually scale the windowsize for any arbitrary scaling on your OS. glfwWindowHint ( GLFW_CLIENT_API , GLFW_NO_API ); GLFW was initially meant to support development of OpenGL based applications, hence the gl in its name, but over the years it also started to support other APIs and not just OpenGL. Now since GLFW automatically creates a context for OpenGL and we want to use DirectX, we will have to tell it to not to do so via glfwWindowHint . There are many other options one can define through glfwWindowHint which can be found here . Many of these options might be useful in your application, depending on what you want and how you want to design your window. GLFWwindow * window = glfwCreateWindow ( width , height , \"LearnD3D11 - Hello Window\" , nullptr , nullptr ); if ( window == nullptr ) { std :: cout << \"GLFW: Unable to create window \\n \" ; glfwTerminate (); return -1 ; } This piece actually creates the window, if everything goes well. We pass in desired window dimensions and a title, and call glfwCreateWindow . Make sure to check the return value, window creation can fail. const int32_t windowLeft = videoMode -> width / 2 - width / 2 ; const int32_t windowTop = videoMode -> height / 2 - height / 2 ; glfwSetWindowPos ( window , windowLeft , windowTop ); GLFW does not center windows automatically, like you can with other libraries like SDL , there for we will center the window manually. All we need is just a bit of math an glfwSetWindowPos . It sets the window position in screen coordinates, specified by the top left corner of the window. while ( ! glfwWindowShouldClose ( window )) { glfwPollEvents (); // future update code // future render code } That is more or less the heart of your application, the mainloop. You could also call it game loop, since in here everything happens. From reading keyboard and mouse input, reacting to it, to telling the graphics card to put a frog on the screen. It will keep doing it, until it gets signaled to not to do that anymore because you closed the window for example ( glfwWindowShouldClose ), or hit Escape and mapped Escape to close the window. glfwPollEvents will make sure that GLFW knows about all required events coming from the operating system. glfwDestroyWindow ( window ); glfwTerminate (); return 0 ; Now we clean up the resources we have created, such as the window itself and the GLFW system. Then simply return to the OS, without any error. glfwDestroyWindow will obviously destroy the window and glfwTerminate cleans up GLFW . When you start the program, you should see something like this. Why GLFW? We have decided to include GLFW to manage our window (and later input) because it is a very simple library, ready to use and above all, because of consistency, plenty of other resources use GLFW, so it should be easier to transfer the knowledge you will gain here elsewhere. There are other libraries, which handle windowing and input (amongst other things) out there as well, here are a few to choose from: SDL2 SFML You could also write all that using the native functions and constructs the OS provides, on windows it would be WinAPI, and although it is old and not necessary to do all the heavylifting yourself, a lot of Microsoft's own guides rely on the WinAPI so we have an example on that. We will not be covering any other Win32 topics, unless it is explicitly required You are probably going to continue writing your own engine after this tutorial and might decide to support more platforms, other than just windows, then this is already covered by GLFW . First abstraction \u00b6 The further we go into this tutorial series the more stuff we will add to the program. But we don't want to cram everything into Main.cpp , your main entry point of the program. A good practise is to split up things into smaller units, to not lose overview. Right now we dont have much to show for, just a window, made by a few lines of code, but we are going to abstract that code into a new class called Application which will also be our main container so to speak, in which all the magic will happen. I will show the whole code first, and then explain again what means what. Application.hpp \u00b6 #pragma once #include <string_view> #include <iostream> struct GLFWwindow ; class Application { public : Application ( const std :: string_view title ); virtual ~ Application (); void Run (); protected : virtual void Cleanup (); virtual bool Initialize (); virtual bool Load () = 0 ; virtual void Render () = 0 ; virtual void Update () = 0 ; private : GLFWwindow * _window = nullptr ; int32_t _width = 0 ; int32_t _height = 0 ; std :: string_view _title ; }; Application.cpp \u00b6 #include \"Application.hpp\" #include <GLFW/glfw3.h> Application :: Application ( const std :: string_view title ) { _title = title ; } Application ::~ Application () { Cleanup (); } void Application :: Run () { if ( ! Initialize ()) { return ; } while ( ! glfwWindowShouldClose ( _window )) { glfwPollEvents (); Update (); Render (); } } void Application :: Cleanup () { if ( _window != nullptr ) { glfwDestroyWindow ( _window ); _window = nullptr ; } glfwTerminate (); } bool Application :: Initialize () { if ( ! glfwInit ()) { std :: cout << \"GLFW: Unable to initialize \\n \" ; return false ; } GLFWmonitor * primaryMonitor = glfwGetPrimaryMonitor (); const GLFWvidmode * videoMode = glfwGetVideoMode ( primaryMonitor ); _width = static_cast < int32_t > ( videoMode -> width * 0.9f ); _height = static_cast < int32_t > ( videoMode -> height * 0.9f ); glfwWindowHint ( GLFW_SCALE_TO_MONITOR , GLFW_FALSE ); glfwWindowHint ( GLFW_CLIENT_API , GLFW_NO_API ); _window = glfwCreateWindow ( _width , _height , _title . data (), nullptr , nullptr ); if ( _window == nullptr ) { std :: cout << \"GLFW: Unable to create window \\n \" ; return false ; } const int32_t windowLeft = videoMode -> width / 2 - _width / 2 ; const int32_t windowTop = videoMode -> height / 2 - _height / 2 ; glfwSetWindowPos ( _window , windowLeft , windowTop ); return true ; } HelloWindowApplication.hpp \u00b6 #include \"Application.hpp\" class HelloWindowApplication final : public Application { public : HelloWindowApplication ( const std :: string_view title ); protected : bool Load () override ; void Render () override ; void Update () override ; } HelloWindowApplication.cpp \u00b6 #include \"HelloWindowApplication.hpp\" HelloWindowApplication :: HelloWindowApplication ( const std :: string_view title ) : Application ( title ) { } bool HelloWindowApplication :: Load () { return true ; } void HelloWindowApplication :: Update () { } void HelloWindowApplication :: Render () { } Main.cpp \u00b6 #include \"HelloWindowApplication.hpp\" int main ( int argc , char * argv []) { HelloWindowApplication application { \"LearnD3D11 - Hello Window\" }; application . Run (); } Let's start with Main.cpp . That's all its doing, creating the hellowindow application and running it. In the future this can be accompanied by loading a configuration, initializing a logger, initiating a connection to a possible server server, or other stuff. public : ... void Run (); ... This is a section of the Application class, showing only its publicly available methods. Run being the most important one to the outside world, like Main , it's the entry point into this Application. We still dont want to cram everything into one main or one method, therefore Run is split up again into the following blocks. void Application::Run () { if ( ! Initialize ()) { return ; } if ( ! Load ()) { return ; } while ( ! glfwWindowShouldClose ( _window )) { glfwPollEvents (); Update (); Render (); } } You can clearly see what it is doing. Initialize , as the name suggests, will initialize everything which is required for the app to run, which currently is the window in our case. In future chapters it will also including initializing D3D11 and its resources or imgui for some UI. Load s purpose is to load all the assets required to run the application, in further chapters it will encompass textures, shaders, models and other things. The next block is the aforementioned mainloop or gameloop, which still does what it was doing before, checking with the OS if events need to be processed and now we also call a Update and Render method. Update may contain queries about pressed key or mouse buttons, updating variables or other things which are - for instance - reflected on display inside the Render method. You probably have noticed that all the protected method in Application are virtual, that's because we are deriving from Application in form of HelloWindowApplication and only focus on those four methods if required. We now dont have to deal with the mainloop anymore for the time being. virtual void Cleanup (); virtual bool Initialize (); virtual bool Load () = 0 ; virtual void Render () = 0 ; virtual void Update () = 0 ; If you run this example, you will still get the same window as shown below, same behaviour, only the code has been spit up into a more logical piece of work, which will make our life easier as we move on adding more and more. Unabstracted Hello Window Project on GitHub Raw Winapi Hello Window Project on GitHub Project on GitHub Next chapter","title":"Hello Window"},{"location":"1-introduction/1-1-getting-started/1-1-1-hello-window/#hello-window","text":"Note If you want to try to follow this series without downloading the full source, you can try this empty project, it has been setup already with all the include directories and libraries you will need throughout the whole series! Link to the full source code Let's start with the whole example code for creating a simple window first. We use the GLFW library to create our window and as you can probably see, it's really not that much code. The following code opens a new blank window titled \"LearnD3D11 - Hello Window\" and will leave it open until you hit close. #include <GLFW/glfw3.h> #include <cstdint> #include <iostream> int main ( int argc , char * argv []) { if ( ! glfwInit ()) { std :: cout << \"GLFW: Unable to initialize \\n \" ; return -1 ; } GLFWmonitor * primaryMonitor = glfwGetPrimaryMonitor (); const GLFWvidmode * videoMode = glfwGetVideoMode ( primaryMonitor ); const int32_t width = static_cast < int32_t > ( videoMode -> width * 0.9f ); const int32_t height = static_cast < int32_t > ( videoMode -> height * 0.9f ); glfwWindowHint ( GLFW_SCALE_TO_MONITOR , GLFW_FALSE ); glfwWindowHint ( GLFW_CLIENT_API , GLFW_NO_API ); GLFWwindow * window = glfwCreateWindow ( width , height , \"LearnD3D11 - Hello Window\" , nullptr , nullptr ); if ( window == nullptr ) { std :: cout << \"GLFW: Unable to create window \\n \" ; glfwTerminate (); return -1 ; } const int32_t windowLeft = videoMode -> width / 2 - width / 2 ; const int32_t windowTop = videoMode -> height / 2 - height / 2 ; glfwSetWindowPos ( window , windowLeft , windowTop ); while ( ! glfwWindowShouldClose ( window )) { glfwPollEvents (); // future update code // future render code } glfwDestroyWindow ( window ); glfwTerminate (); return 0 ; } Now let's go over everything in that example in more detail. #include <GLFW/glfw3.h> C++ needs to know where all the definitions and declarations are coming from. We therefore have to include the GLFW header so that everything we need is present in our source file. if ( ! glfwInit ()) { std :: cout << \"GLFW: Unable to initialize \\n \" ; return -1 ; } Pretty obvious, right? glfwInit tries to initialize GLFW . If it fails to do so, let the user know and end the program, since there is no point in going further. GLFWmonitor * primaryMonitor = glfwGetPrimaryMonitor (); const GLFWvidmode * videoMode = glfwGetVideoMode ( primaryMonitor ); const int32_t width = static_cast < int32_t > ( videoMode -> width * 0.9f ); const int32_t height = static_cast < int32_t > ( videoMode -> height * 0.9f ); This piece of code grabs the main monitor via glfwGetPrimaryMonitor and its current resolution with glfwGetVideoMode , so that we can derive a window width and height from it - and it will look similar no matter what resolution you use. Size-wise it will cover 90% of your main monitor. glfwWindowHint ( GLFW_SCALE_TO_MONITOR , GLFW_FALSE ); This will tell GLFW to not scale the window in any way, should you have setup a specific scaling other than 100% on your desktop. That will keep the windowsize at what we set it, without thinking about odd fractionals to manually scale the windowsize for any arbitrary scaling on your OS. glfwWindowHint ( GLFW_CLIENT_API , GLFW_NO_API ); GLFW was initially meant to support development of OpenGL based applications, hence the gl in its name, but over the years it also started to support other APIs and not just OpenGL. Now since GLFW automatically creates a context for OpenGL and we want to use DirectX, we will have to tell it to not to do so via glfwWindowHint . There are many other options one can define through glfwWindowHint which can be found here . Many of these options might be useful in your application, depending on what you want and how you want to design your window. GLFWwindow * window = glfwCreateWindow ( width , height , \"LearnD3D11 - Hello Window\" , nullptr , nullptr ); if ( window == nullptr ) { std :: cout << \"GLFW: Unable to create window \\n \" ; glfwTerminate (); return -1 ; } This piece actually creates the window, if everything goes well. We pass in desired window dimensions and a title, and call glfwCreateWindow . Make sure to check the return value, window creation can fail. const int32_t windowLeft = videoMode -> width / 2 - width / 2 ; const int32_t windowTop = videoMode -> height / 2 - height / 2 ; glfwSetWindowPos ( window , windowLeft , windowTop ); GLFW does not center windows automatically, like you can with other libraries like SDL , there for we will center the window manually. All we need is just a bit of math an glfwSetWindowPos . It sets the window position in screen coordinates, specified by the top left corner of the window. while ( ! glfwWindowShouldClose ( window )) { glfwPollEvents (); // future update code // future render code } That is more or less the heart of your application, the mainloop. You could also call it game loop, since in here everything happens. From reading keyboard and mouse input, reacting to it, to telling the graphics card to put a frog on the screen. It will keep doing it, until it gets signaled to not to do that anymore because you closed the window for example ( glfwWindowShouldClose ), or hit Escape and mapped Escape to close the window. glfwPollEvents will make sure that GLFW knows about all required events coming from the operating system. glfwDestroyWindow ( window ); glfwTerminate (); return 0 ; Now we clean up the resources we have created, such as the window itself and the GLFW system. Then simply return to the OS, without any error. glfwDestroyWindow will obviously destroy the window and glfwTerminate cleans up GLFW . When you start the program, you should see something like this. Why GLFW? We have decided to include GLFW to manage our window (and later input) because it is a very simple library, ready to use and above all, because of consistency, plenty of other resources use GLFW, so it should be easier to transfer the knowledge you will gain here elsewhere. There are other libraries, which handle windowing and input (amongst other things) out there as well, here are a few to choose from: SDL2 SFML You could also write all that using the native functions and constructs the OS provides, on windows it would be WinAPI, and although it is old and not necessary to do all the heavylifting yourself, a lot of Microsoft's own guides rely on the WinAPI so we have an example on that. We will not be covering any other Win32 topics, unless it is explicitly required You are probably going to continue writing your own engine after this tutorial and might decide to support more platforms, other than just windows, then this is already covered by GLFW .","title":"Hello Window"},{"location":"1-introduction/1-1-getting-started/1-1-1-hello-window/#first-abstraction","text":"The further we go into this tutorial series the more stuff we will add to the program. But we don't want to cram everything into Main.cpp , your main entry point of the program. A good practise is to split up things into smaller units, to not lose overview. Right now we dont have much to show for, just a window, made by a few lines of code, but we are going to abstract that code into a new class called Application which will also be our main container so to speak, in which all the magic will happen. I will show the whole code first, and then explain again what means what.","title":"First abstraction"},{"location":"1-introduction/1-1-getting-started/1-1-1-hello-window/#applicationhpp","text":"#pragma once #include <string_view> #include <iostream> struct GLFWwindow ; class Application { public : Application ( const std :: string_view title ); virtual ~ Application (); void Run (); protected : virtual void Cleanup (); virtual bool Initialize (); virtual bool Load () = 0 ; virtual void Render () = 0 ; virtual void Update () = 0 ; private : GLFWwindow * _window = nullptr ; int32_t _width = 0 ; int32_t _height = 0 ; std :: string_view _title ; };","title":"Application.hpp"},{"location":"1-introduction/1-1-getting-started/1-1-1-hello-window/#applicationcpp","text":"#include \"Application.hpp\" #include <GLFW/glfw3.h> Application :: Application ( const std :: string_view title ) { _title = title ; } Application ::~ Application () { Cleanup (); } void Application :: Run () { if ( ! Initialize ()) { return ; } while ( ! glfwWindowShouldClose ( _window )) { glfwPollEvents (); Update (); Render (); } } void Application :: Cleanup () { if ( _window != nullptr ) { glfwDestroyWindow ( _window ); _window = nullptr ; } glfwTerminate (); } bool Application :: Initialize () { if ( ! glfwInit ()) { std :: cout << \"GLFW: Unable to initialize \\n \" ; return false ; } GLFWmonitor * primaryMonitor = glfwGetPrimaryMonitor (); const GLFWvidmode * videoMode = glfwGetVideoMode ( primaryMonitor ); _width = static_cast < int32_t > ( videoMode -> width * 0.9f ); _height = static_cast < int32_t > ( videoMode -> height * 0.9f ); glfwWindowHint ( GLFW_SCALE_TO_MONITOR , GLFW_FALSE ); glfwWindowHint ( GLFW_CLIENT_API , GLFW_NO_API ); _window = glfwCreateWindow ( _width , _height , _title . data (), nullptr , nullptr ); if ( _window == nullptr ) { std :: cout << \"GLFW: Unable to create window \\n \" ; return false ; } const int32_t windowLeft = videoMode -> width / 2 - _width / 2 ; const int32_t windowTop = videoMode -> height / 2 - _height / 2 ; glfwSetWindowPos ( _window , windowLeft , windowTop ); return true ; }","title":"Application.cpp"},{"location":"1-introduction/1-1-getting-started/1-1-1-hello-window/#hellowindowapplicationhpp","text":"#include \"Application.hpp\" class HelloWindowApplication final : public Application { public : HelloWindowApplication ( const std :: string_view title ); protected : bool Load () override ; void Render () override ; void Update () override ; }","title":"HelloWindowApplication.hpp"},{"location":"1-introduction/1-1-getting-started/1-1-1-hello-window/#hellowindowapplicationcpp","text":"#include \"HelloWindowApplication.hpp\" HelloWindowApplication :: HelloWindowApplication ( const std :: string_view title ) : Application ( title ) { } bool HelloWindowApplication :: Load () { return true ; } void HelloWindowApplication :: Update () { } void HelloWindowApplication :: Render () { }","title":"HelloWindowApplication.cpp"},{"location":"1-introduction/1-1-getting-started/1-1-1-hello-window/#maincpp","text":"#include \"HelloWindowApplication.hpp\" int main ( int argc , char * argv []) { HelloWindowApplication application { \"LearnD3D11 - Hello Window\" }; application . Run (); } Let's start with Main.cpp . That's all its doing, creating the hellowindow application and running it. In the future this can be accompanied by loading a configuration, initializing a logger, initiating a connection to a possible server server, or other stuff. public : ... void Run (); ... This is a section of the Application class, showing only its publicly available methods. Run being the most important one to the outside world, like Main , it's the entry point into this Application. We still dont want to cram everything into one main or one method, therefore Run is split up again into the following blocks. void Application::Run () { if ( ! Initialize ()) { return ; } if ( ! Load ()) { return ; } while ( ! glfwWindowShouldClose ( _window )) { glfwPollEvents (); Update (); Render (); } } You can clearly see what it is doing. Initialize , as the name suggests, will initialize everything which is required for the app to run, which currently is the window in our case. In future chapters it will also including initializing D3D11 and its resources or imgui for some UI. Load s purpose is to load all the assets required to run the application, in further chapters it will encompass textures, shaders, models and other things. The next block is the aforementioned mainloop or gameloop, which still does what it was doing before, checking with the OS if events need to be processed and now we also call a Update and Render method. Update may contain queries about pressed key or mouse buttons, updating variables or other things which are - for instance - reflected on display inside the Render method. You probably have noticed that all the protected method in Application are virtual, that's because we are deriving from Application in form of HelloWindowApplication and only focus on those four methods if required. We now dont have to deal with the mainloop anymore for the time being. virtual void Cleanup (); virtual bool Initialize (); virtual bool Load () = 0 ; virtual void Render () = 0 ; virtual void Update () = 0 ; If you run this example, you will still get the same window as shown below, same behaviour, only the code has been spit up into a more logical piece of work, which will make our life easier as we move on adding more and more. Unabstracted Hello Window Project on GitHub Raw Winapi Hello Window Project on GitHub Project on GitHub Next chapter","title":"Main.cpp"},{"location":"1-introduction/1-1-getting-started/1-1-2-hello-d3d11/","text":"Hello D3D11 \u00b6 In this chapter, we'll introduce you to the basics of using D3D11; how to create a ID3D11Device and how to use it to show something in our window. In the last chapter we setup a basic implementation for an application with a window through GLFW. The implementation for Main.cpp and Application.cpp won't be shown here anymore. If you are looking at the source code for this chapter, you will also notice that Application.cpp and Application.hpp do not exist anymore, as we have moved both of these files into a separate Framework project to ease development between chapters. This Framework project will include code that is shared between all chapters, so it might include a lot of other files which are not used or are not relevant within some chapters. Please note that the code for already existing files is also subject to change to accomodate newer chapters and their needs. However, let's start by breaking down the relevant bits and pieces by showing you how the new class, which derives from Application will look like. HelloD3D11.hpp \u00b6 #include <d3d11_2.h> #include <wrl.h> #include \"Application.hpp\" #include <string_view> class HelloD3D11Application final : public Application { template < typename T > using ComPtr = Microsoft :: WRL :: ComPtr < T > ; public : HelloD3D11Application ( const std :: string_view title ); ~ HelloD3D11Application () override ; protected : bool Initialize () override ; bool Load () override ; void OnResize ( const int32_t width , const int32_t height ) override ; void Update () override ; void Render () override ; private : bool CreateSwapchainResources (); void DestroySwapchainResources (); ComPtr < ID3D11Device > _device = nullptr ; ComPtr < ID3D11DeviceContext > _deviceContext = nullptr ; ComPtr < IDXGIFactory2 > _dxgiFactory = nullptr ; ComPtr < IDXGISwapChain1 > _swapChain = nullptr ; ComPtr < ID3D11RenderTargetView > _renderTarget = nullptr ; }; HelloD3D11.cpp \u00b6 And the implementation side #include \"HelloD3D11.hpp\" #include <GLFW/glfw3.h> #define GLFW_EXPOSE_NATIVE_WIN32 #include <GLFW/glfw3native.h> #include <d3dcompiler.h> #include <DirectXMath.h> #include <iostream> #pragma comment(lib, \"d3d11.lib\") #pragma comment(lib, \"dxgi.lib\") #pragma comment(lib, \"d3dcompiler.lib\") #pragma comment(lib, \"winmm.lib\") #pragma comment(lib, \"dxguid.lib\") HelloD3D11Application :: HelloD3D11Application ( const std :: string_view title ) : Application ( title ) { } HelloD3D11Application ::~ HelloD3D11Application () { } bool HelloD3D11Application :: Initialize () { } bool HelloD3D11Application :: Load () { return true ; } bool HelloD3D11Application :: CreateSwapchainResources () { } void HelloD3D11Application :: DestroySwapchainResources () { } void HelloD3D11Application :: OnResize ( const int32_t width , const int32_t height ) { } void HelloD3D11Application :: Update () { } void HelloD3D11Application :: Render () { } #include <GLFW/glfw3.h> #define GLFW_EXPOSE_NATIVE_WIN32 #include <GLFW/glfw3native.h> #include <d3dcompiler.h> #include <DirectXMath.h> We need to include the following headers, here's what each of these headers includes: d3d11.h : The core of D3D11, it contains all the ID3D11XXX types and most of the enums we will be using with D3D11 dxgi.h : The core of DXGI, it contains all the IDXGIXXX types and additional enums that are required for DXGI structures d3dcompiler.h : Contains all the functions necessary to compiler our HLSL shaders into bytecode that will be fed into the GPU DirectXMath.h : DirectX's own math library, it contains all the types and math functions we will be using throughout the series wrl.h : Is used for Microsoft::WRL::ComPtr<T> , to manage COM resources automatically. #pragma comment(lib, \"d3d11.lib\") #pragma comment(lib, \"dxgi.lib\") #pragma comment(lib, \"d3dcompiler.lib\") #pragma comment(lib, \"winmm.lib\") #pragma comment(lib, \"dxguid.lib\") Of course just including the headers isn't enough, we must also link against D3D11 & friends to be able to actually use the stuff declared in the headers, put these #pragma comment(lib, \"PATH_TO_LIB\") in HelloD3D11.cpp right below the includes to link these libraries. template < typename T > using ComPtr = Microsoft :: WRL :: ComPtr < T > ; Since the namespace name for ComPtr is quite long, we are making a type alias like this. ComPtr < IDXGIFactory2 > _dxgiFactory = nullptr ; ComPtr < ID3D11Device > _device = nullptr ; ComPtr < ID3D11DeviceContext > _deviceContext = nullptr ; ComPtr < IDXGISwapChain1 > _swapChain = nullptr ; ComPtr < ID3D11RenderTargetView > _renderTarget = nullptr ; You might have noticed that we are not using raw pointers for those pieces, but ComPtr . DirectX is built on top of COM ( Component Object Model ) and with that COM objects utilize reference counting to manage object lifetimes, in form of AddRef and Release methods. ComPtr<T> wraps that functionlity for us, by creating a smart pointer. You can find more information about it here . IDXGIFactory2 helps us find an adapter we can use to run our graphics on. It can enumerate all existing adapters (GPUs), of which there could be several installed in your system. If you have a laptop there is most likely an integrated one coming with your cpu, but often these days laptops also have a dedicated GPU as well, or your PC might have more than one dedicated GPUs installed. With IDXGIFactory2 we can pick one. It also creates the swapchain for us, a surface to store rendered data before presenting it to an output (or screen). ID3D11Device is the object which we use to create all sorts of things, buffers, textures, samplers, shaders. ID3D11DeviceContext is the one we use to issue draw and compute commands to the GPU. IDXGISwapChain1 The aforementioned surface, which stores rendered data which it can present to an output (or screen). ID3D11RenderTargetView Is a fancy pointer to a texture, this tells D3D11 that the texture this points to, is drawable within the subresource of the referenced texture DXGI stands for DirectX Graphics Infrastructure, in case you are wondering. Lets go in to Initialize if ( ! Application :: Initialize ()) { return false ; } if ( FAILED ( CreateDXGIFactory2 ( 0 , IID_PPV_ARGS ( & _dxgiFactory )))) { std :: cout << \"DXGI: Unable to create DXGIFactory \\n \" ; return false ; } The first part calls the parent class, where GLFW is initialized and setup. IID_PPV_ARGS(ppType) Is a compile time macro that is defined as #define IID_PPV_ARGS(ppType) __uuidof(**(ppType)), IID_PPV_ARGS_Helper(ppType) Which means that typing IID_PPV_ARGS(&_dxgiFactory) it is expanded by the compiler into __uuidof(**(&_dxgiFactory)), IID_PPV_ARGS_Helper(_dxgiFactory) . This functionally means that for functions that have a parameter setup as REFIID and functionally after a [out] void** parameter, this macro will expand the IID_PPV_ARGS(ppType) expression into these parameters for ease of use \u2014 this can be seen with the used CreateDXGIFactory2 method where the second last and last parameter are a REFIID and void** : HRESULT CreateDXGIFactory2 ( UINT Flags , REFIID riid , [ out ] void ** ppFactory ); REFIID is a typedef that is a Reference (REF) to an Interface Identifier type ( IID ) \u2014 this means that it is a reference to a type that uniquely identifies a COM object. [more information like underlying memory organization can be read about IID's at https://docs.microsoft.com/en-us/office/client-developer/outlook/mapi/iid] What the parts of the IID_PPV_ARGS(ppType) macro are: [the ppType in IID_PPV_ARGS(ppType) ] - a pointer to a pointer of a object. [the __uuidof(**(ppType)) part of IID_PPV_ARGS(ppType) ] - at compile time retrieves a UUID from ppType type which represents a GUID , which is returned as a REFIID \u2014 which means that the type returned is a reference to an identifier to a specific type of COM object. Explain DXGI https://docs.microsoft.com/en-us/windows/win32/direct3ddxgi/d3d10-graphics-programming-guide-dxgi CreateDXGIFactory2 is the entry point to create a factory for us, a IDXGIFactory2 to be precise. There are various implementations of it, depending on what version you aim for, you get additional functionality. DXGI 1.0 up to 1.6 More information can be found here We will stick with IDXGIFactory2 for now. constexpr D3D_FEATURE_LEVEL deviceFeatureLevel = D3D_FEATURE_LEVEL :: D3D_FEATURE_LEVEL_11_0 ; constexpr UINT deviceFlags = D3D11_CREATE_DEVICE_FLAG :: D3D11_CREATE_DEVICE_BGRA_SUPPORT ; if ( FAILED ( D3D11CreateDevice ( nullptr , D3D_DRIVER_TYPE :: D3D_DRIVER_TYPE_HARDWARE , nullptr , deviceFlags , & deviceFeatureLevel , 1 , D3D11_SDK_VERSION , & _device , nullptr , & _deviceContext ))) { std :: cout << \"D3D11: Failed to create Device and Device Context \\n \" ; return false ; } This block is the the entry point into D3D11, where we ask for a device and its device context to be created. The input parameters are: We want a LEVEL_11_0, hardware accelerated device, which has support for a specific color format. Feature levels are a concept that has been introduced with D3D11, it is a way to specify which set of features we would like to use. Each GPU may support different feature levels (for example a very old GPU might only support LEVEL_9_1, while a more modern one may support every feature level up to, and including LEVEL_11_0), this is a way to avoid rewriting our application in D3D9 just because our GPU doesn't support D3D11. If D3D11CreateDevice succeeds we will get a ID3D11Device and a ID3D11DeviceContext back. DXGI_SWAP_CHAIN_DESC1 swapChainDescriptor = {}; swapChainDescriptor . Width = GetWindowWidth (); swapChainDescriptor . Height = GetWindowHeight (); swapChainDescriptor . Format = DXGI_FORMAT :: DXGI_FORMAT_B8G8R8A8_UNORM ; swapChainDescriptor . SampleDesc . Count = 1 ; swapChainDescriptor . SampleDesc . Quality = 0 ; swapChainDescriptor . BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT ; swapChainDescriptor . BufferCount = 2 ; swapChainDescriptor . SwapEffect = DXGI_SWAP_EFFECT :: DXGI_SWAP_EFFECT_FLIP_DISCARD ; swapChainDescriptor . Flags = {}; DXGI_SWAP_CHAIN_FULLSCREEN_DESC swapChainFullscreenDescriptor = {}; swapChainFullscreenDescriptor . Windowed = true ; if ( FAILED ( _dxgiFactory -> CreateSwapChainForHwnd ( _device . Get (), glfwGetWin32Window ( GetWindow ()), & swapChainDescriptor , & swapChainFullscreenDescriptor , nullptr , & _swapChain ))) { std :: cout << \"DXGI: Failed to create SwapChain \\n \" ; return false ; } After we successfully create device and device context, the next step is to create a swapchain, that storage containing the rendered images which we can present to the screen. The majority of values should make some sense without explanation, like width and height, and whether we want it to support a windowed window or not. BufferUsage tells the swapchain's buffers their usage, something we render to, and can present. The format here is in BGRA order, like the device creation flag we specified earlier, if you remember. Scaling tells DXGI to scale the buffer's contents to fit the presentation's target size. BufferCount is 2, because we want double buffering. Double buffering is an age-old technique to avoid presenting an image that is being used by the GPU, instead we work on the \"back buffer\", while the GPU is happy presenting the \"front buffer\", then, as soon as we are done with the back buffer, we swap front and back, and begin working on the former front buffer present that one and render to the other one again in the meantime. That process is supposed to reduce flicker or tearing. SwapEffect specifies if the contents of the back buffer should be preserved or discarded after a swap, here we don't care about preserving the back buffer so we just discard everything. AlphaMode specifies how DXGI should handle transparency, we don't care about that (yet), so we'll just say it's unspecified and rely on default behaviour if ( ! CreateSwapchainResources ()) { return false ; } return true ; And the last bits of the Initialize method. We need to create a few more things. Those are based on the swapchain, hence their name. These resources need to be destroyed and recreated whenever we want to resize the window. When that happens, the swapchain needs to be resized as well (since that is a prameter in its descriptor as you can see above) bool HelloD3D11Application::CreateSwapchainResources () { ComPtr < ID3D11Texture2D > backBuffer = nullptr ; if ( FAILED ( _swapChain -> GetBuffer ( 0 , IID_PPV_ARGS ( & backBuffer )))) { std :: cout << \"D3D11: Failed to get Back Buffer from the SwapChain \\n \" ; return false ; } if ( FAILED ( _device -> CreateRenderTargetView ( backBuffer . Get (), nullptr , & _renderTarget ))) { std :: cout << \"D3D11: Failed to create RTV from Back Buffer \\n \" ; return false ; } return true ; } When we render things, the GPU simply writes color values to a texture, which you can picture as a buffer which holds color information Swapchain is a container to manage those buffers we want to present on screen. To do that we have to create a special kind of texture called a \"Render Target View\" or an RTV. First off we have to grab a texture from the swapchain's main buffer (index 0), from that texture, we now have create an RTV from that, which specifies the subresource of the texture that we will be drawing to. We wont keep the actual texture around, we just need the render target view, which we will refer to as render target. void HelloD3D11Application::DestroySwapchainResources () { _renderTarget . Reset (); } The render target needs to be disposed when we want to resize (or cleanup in general), it will be recreated via CreateSwapchainResources when we resize the window as shown here: void HelloD3D11Application::OnResize ( const int32_t width , const int32_t height ) { Application :: OnResize ( width , height ); _deviceContext -> Flush (); DestroySwapchainResources (); if ( FAILED ( _swapChain -> ResizeBuffers ( 0 , width , height , DXGI_FORMAT :: DXGI_FORMAT_B8G8R8A8_UNORM , 0 ))) { std :: cout << \"D3D11: Failed to recreate SwapChain buffers \\n \" ; return ; } CreateSwapchainResources (); } When we resize, let the base application know about it, and make sure the device context has done all its work ( Flush ) Before we can resize the swapchain, make sure all resources based on it are disposed. Afterwards recreate them with the new dimensions of the swapchain void HelloD3D11Application::Render () { D3D11_VIEWPORT viewport = {}; viewport . TopLeftX = 0 ; viewport . TopLeftY = 0 ; viewport . Width = GetWindowWidth (); viewport . Height = GetWindowHeight (); viewport . MinDepth = 0.0f ; viewport . MaxDepth = 1.0f ; constexpr float clearColor [] = { 0.1f , 0.1f , 0.1f , 1.0f }; _deviceContext -> ClearRenderTargetView ( _renderTarget . Get (), clearColor ); _deviceContext -> RSSetViewports ( 1 , & viewport ); _deviceContext -> OMSetRenderTargets ( 1 , _renderTarget . GetAddressOf (), nullptr ); _swapChain -> Present ( 1 , 0 ); } Now we can actually use those things we have created before. We just set it up so that we tell D3D11 that we want to render into the render target, and when we clear we want to use a dark gray. We also have to specify an area in form of a rectangle, in this case, its equivalent to the window size. Last but not least, we Present the content of the swapchain to the window, using Present . The first argument defines which vblanks to synchronize with presentation, 0 means: no synchronization (unlimited FPS), 1 means: sync every v-blank (regular v-sync), 2 means: sync every other v-blank and so on, up to 4. The second are optional flags, we don't need them so 0 is passed. Application also defines an abstract method Update which we have to define here as well, so we will add: void HelloD3D11Application::Update () { } But keep it empty for now. Same applies for Application 's Load method. bool HelloD3D11Application::Load () { return true ; } Finally we need to modify Appplication.hpp and Application.cpp . Since we want to handle resizing as well. Application.hpp \u00b6 Find protected: and add the following lines static void HandleResize ( GLFWwindow * window , const int32_t width , const int32_t height ); virtual void OnResize ( const int32_t width , const int32_t height ); [[ nodiscard ]] GLFWwindow * GetWindow () const ; [[ nodiscard ]] int32_t GetWindowWidth () const ; [[ nodiscard ]] int32_t GetWindowHeight () const ; HandleResize will be the callback from GLFW which handles resize events and OnResize will be execute when GLFW runs HandleResize, so that we can handle our custom things we want to execute when resizing the window, like changing the size of the swapchain in our example. GetWindow() is used to derive the actual native window handle from, which is needed when we create the swapchain. GetWindowWidth() and GetWindowHeight() do what they say :) Also required for swapchain creation. Application.cpp \u00b6 Add the following lines void Application::OnResize ( const int32_t width , const int32_t height ) { _width = width ; _height = height ; } void Application::HandleResize ( GLFWwindow * window , const int32_t width , const int32_t height ) { Application & application = * static_cast < Application *> ( glfwGetWindowUserPointer ( window )); application . OnResize ( width , height ); } GLFWwindow * Application::GetWindow () const { return _window ; } int32_t Application::GetWindowWidth () const { return _width ; } int32_t Application::GetWindowHeight () const { return _height ; } Find the Initialize method and add the following two lines before return true; glfwSetWindowUserPointer ( _window , this ); glfwSetFramebufferSizeCallback ( _window , HandleResize ); glfwSetWindowUserPointer will set our application instance as a custom variable, so that we can retrieve it using glfwGetWindowUserPointer in the HandleResize callback. glfwSetFramebufferSizeCallback will tell GLFW what to do when we resize the window, in this case execute HandleResize which will fetch our application instance and all OnResize on it, where we can handle resizing in our application code. Project on GitHub Next chapter","title":"Hello D3D11"},{"location":"1-introduction/1-1-getting-started/1-1-2-hello-d3d11/#hello-d3d11","text":"In this chapter, we'll introduce you to the basics of using D3D11; how to create a ID3D11Device and how to use it to show something in our window. In the last chapter we setup a basic implementation for an application with a window through GLFW. The implementation for Main.cpp and Application.cpp won't be shown here anymore. If you are looking at the source code for this chapter, you will also notice that Application.cpp and Application.hpp do not exist anymore, as we have moved both of these files into a separate Framework project to ease development between chapters. This Framework project will include code that is shared between all chapters, so it might include a lot of other files which are not used or are not relevant within some chapters. Please note that the code for already existing files is also subject to change to accomodate newer chapters and their needs. However, let's start by breaking down the relevant bits and pieces by showing you how the new class, which derives from Application will look like.","title":"Hello D3D11"},{"location":"1-introduction/1-1-getting-started/1-1-2-hello-d3d11/#hellod3d11hpp","text":"#include <d3d11_2.h> #include <wrl.h> #include \"Application.hpp\" #include <string_view> class HelloD3D11Application final : public Application { template < typename T > using ComPtr = Microsoft :: WRL :: ComPtr < T > ; public : HelloD3D11Application ( const std :: string_view title ); ~ HelloD3D11Application () override ; protected : bool Initialize () override ; bool Load () override ; void OnResize ( const int32_t width , const int32_t height ) override ; void Update () override ; void Render () override ; private : bool CreateSwapchainResources (); void DestroySwapchainResources (); ComPtr < ID3D11Device > _device = nullptr ; ComPtr < ID3D11DeviceContext > _deviceContext = nullptr ; ComPtr < IDXGIFactory2 > _dxgiFactory = nullptr ; ComPtr < IDXGISwapChain1 > _swapChain = nullptr ; ComPtr < ID3D11RenderTargetView > _renderTarget = nullptr ; };","title":"HelloD3D11.hpp"},{"location":"1-introduction/1-1-getting-started/1-1-2-hello-d3d11/#hellod3d11cpp","text":"And the implementation side #include \"HelloD3D11.hpp\" #include <GLFW/glfw3.h> #define GLFW_EXPOSE_NATIVE_WIN32 #include <GLFW/glfw3native.h> #include <d3dcompiler.h> #include <DirectXMath.h> #include <iostream> #pragma comment(lib, \"d3d11.lib\") #pragma comment(lib, \"dxgi.lib\") #pragma comment(lib, \"d3dcompiler.lib\") #pragma comment(lib, \"winmm.lib\") #pragma comment(lib, \"dxguid.lib\") HelloD3D11Application :: HelloD3D11Application ( const std :: string_view title ) : Application ( title ) { } HelloD3D11Application ::~ HelloD3D11Application () { } bool HelloD3D11Application :: Initialize () { } bool HelloD3D11Application :: Load () { return true ; } bool HelloD3D11Application :: CreateSwapchainResources () { } void HelloD3D11Application :: DestroySwapchainResources () { } void HelloD3D11Application :: OnResize ( const int32_t width , const int32_t height ) { } void HelloD3D11Application :: Update () { } void HelloD3D11Application :: Render () { } #include <GLFW/glfw3.h> #define GLFW_EXPOSE_NATIVE_WIN32 #include <GLFW/glfw3native.h> #include <d3dcompiler.h> #include <DirectXMath.h> We need to include the following headers, here's what each of these headers includes: d3d11.h : The core of D3D11, it contains all the ID3D11XXX types and most of the enums we will be using with D3D11 dxgi.h : The core of DXGI, it contains all the IDXGIXXX types and additional enums that are required for DXGI structures d3dcompiler.h : Contains all the functions necessary to compiler our HLSL shaders into bytecode that will be fed into the GPU DirectXMath.h : DirectX's own math library, it contains all the types and math functions we will be using throughout the series wrl.h : Is used for Microsoft::WRL::ComPtr<T> , to manage COM resources automatically. #pragma comment(lib, \"d3d11.lib\") #pragma comment(lib, \"dxgi.lib\") #pragma comment(lib, \"d3dcompiler.lib\") #pragma comment(lib, \"winmm.lib\") #pragma comment(lib, \"dxguid.lib\") Of course just including the headers isn't enough, we must also link against D3D11 & friends to be able to actually use the stuff declared in the headers, put these #pragma comment(lib, \"PATH_TO_LIB\") in HelloD3D11.cpp right below the includes to link these libraries. template < typename T > using ComPtr = Microsoft :: WRL :: ComPtr < T > ; Since the namespace name for ComPtr is quite long, we are making a type alias like this. ComPtr < IDXGIFactory2 > _dxgiFactory = nullptr ; ComPtr < ID3D11Device > _device = nullptr ; ComPtr < ID3D11DeviceContext > _deviceContext = nullptr ; ComPtr < IDXGISwapChain1 > _swapChain = nullptr ; ComPtr < ID3D11RenderTargetView > _renderTarget = nullptr ; You might have noticed that we are not using raw pointers for those pieces, but ComPtr . DirectX is built on top of COM ( Component Object Model ) and with that COM objects utilize reference counting to manage object lifetimes, in form of AddRef and Release methods. ComPtr<T> wraps that functionlity for us, by creating a smart pointer. You can find more information about it here . IDXGIFactory2 helps us find an adapter we can use to run our graphics on. It can enumerate all existing adapters (GPUs), of which there could be several installed in your system. If you have a laptop there is most likely an integrated one coming with your cpu, but often these days laptops also have a dedicated GPU as well, or your PC might have more than one dedicated GPUs installed. With IDXGIFactory2 we can pick one. It also creates the swapchain for us, a surface to store rendered data before presenting it to an output (or screen). ID3D11Device is the object which we use to create all sorts of things, buffers, textures, samplers, shaders. ID3D11DeviceContext is the one we use to issue draw and compute commands to the GPU. IDXGISwapChain1 The aforementioned surface, which stores rendered data which it can present to an output (or screen). ID3D11RenderTargetView Is a fancy pointer to a texture, this tells D3D11 that the texture this points to, is drawable within the subresource of the referenced texture DXGI stands for DirectX Graphics Infrastructure, in case you are wondering. Lets go in to Initialize if ( ! Application :: Initialize ()) { return false ; } if ( FAILED ( CreateDXGIFactory2 ( 0 , IID_PPV_ARGS ( & _dxgiFactory )))) { std :: cout << \"DXGI: Unable to create DXGIFactory \\n \" ; return false ; } The first part calls the parent class, where GLFW is initialized and setup. IID_PPV_ARGS(ppType) Is a compile time macro that is defined as #define IID_PPV_ARGS(ppType) __uuidof(**(ppType)), IID_PPV_ARGS_Helper(ppType) Which means that typing IID_PPV_ARGS(&_dxgiFactory) it is expanded by the compiler into __uuidof(**(&_dxgiFactory)), IID_PPV_ARGS_Helper(_dxgiFactory) . This functionally means that for functions that have a parameter setup as REFIID and functionally after a [out] void** parameter, this macro will expand the IID_PPV_ARGS(ppType) expression into these parameters for ease of use \u2014 this can be seen with the used CreateDXGIFactory2 method where the second last and last parameter are a REFIID and void** : HRESULT CreateDXGIFactory2 ( UINT Flags , REFIID riid , [ out ] void ** ppFactory ); REFIID is a typedef that is a Reference (REF) to an Interface Identifier type ( IID ) \u2014 this means that it is a reference to a type that uniquely identifies a COM object. [more information like underlying memory organization can be read about IID's at https://docs.microsoft.com/en-us/office/client-developer/outlook/mapi/iid] What the parts of the IID_PPV_ARGS(ppType) macro are: [the ppType in IID_PPV_ARGS(ppType) ] - a pointer to a pointer of a object. [the __uuidof(**(ppType)) part of IID_PPV_ARGS(ppType) ] - at compile time retrieves a UUID from ppType type which represents a GUID , which is returned as a REFIID \u2014 which means that the type returned is a reference to an identifier to a specific type of COM object. Explain DXGI https://docs.microsoft.com/en-us/windows/win32/direct3ddxgi/d3d10-graphics-programming-guide-dxgi CreateDXGIFactory2 is the entry point to create a factory for us, a IDXGIFactory2 to be precise. There are various implementations of it, depending on what version you aim for, you get additional functionality. DXGI 1.0 up to 1.6 More information can be found here We will stick with IDXGIFactory2 for now. constexpr D3D_FEATURE_LEVEL deviceFeatureLevel = D3D_FEATURE_LEVEL :: D3D_FEATURE_LEVEL_11_0 ; constexpr UINT deviceFlags = D3D11_CREATE_DEVICE_FLAG :: D3D11_CREATE_DEVICE_BGRA_SUPPORT ; if ( FAILED ( D3D11CreateDevice ( nullptr , D3D_DRIVER_TYPE :: D3D_DRIVER_TYPE_HARDWARE , nullptr , deviceFlags , & deviceFeatureLevel , 1 , D3D11_SDK_VERSION , & _device , nullptr , & _deviceContext ))) { std :: cout << \"D3D11: Failed to create Device and Device Context \\n \" ; return false ; } This block is the the entry point into D3D11, where we ask for a device and its device context to be created. The input parameters are: We want a LEVEL_11_0, hardware accelerated device, which has support for a specific color format. Feature levels are a concept that has been introduced with D3D11, it is a way to specify which set of features we would like to use. Each GPU may support different feature levels (for example a very old GPU might only support LEVEL_9_1, while a more modern one may support every feature level up to, and including LEVEL_11_0), this is a way to avoid rewriting our application in D3D9 just because our GPU doesn't support D3D11. If D3D11CreateDevice succeeds we will get a ID3D11Device and a ID3D11DeviceContext back. DXGI_SWAP_CHAIN_DESC1 swapChainDescriptor = {}; swapChainDescriptor . Width = GetWindowWidth (); swapChainDescriptor . Height = GetWindowHeight (); swapChainDescriptor . Format = DXGI_FORMAT :: DXGI_FORMAT_B8G8R8A8_UNORM ; swapChainDescriptor . SampleDesc . Count = 1 ; swapChainDescriptor . SampleDesc . Quality = 0 ; swapChainDescriptor . BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT ; swapChainDescriptor . BufferCount = 2 ; swapChainDescriptor . SwapEffect = DXGI_SWAP_EFFECT :: DXGI_SWAP_EFFECT_FLIP_DISCARD ; swapChainDescriptor . Flags = {}; DXGI_SWAP_CHAIN_FULLSCREEN_DESC swapChainFullscreenDescriptor = {}; swapChainFullscreenDescriptor . Windowed = true ; if ( FAILED ( _dxgiFactory -> CreateSwapChainForHwnd ( _device . Get (), glfwGetWin32Window ( GetWindow ()), & swapChainDescriptor , & swapChainFullscreenDescriptor , nullptr , & _swapChain ))) { std :: cout << \"DXGI: Failed to create SwapChain \\n \" ; return false ; } After we successfully create device and device context, the next step is to create a swapchain, that storage containing the rendered images which we can present to the screen. The majority of values should make some sense without explanation, like width and height, and whether we want it to support a windowed window or not. BufferUsage tells the swapchain's buffers their usage, something we render to, and can present. The format here is in BGRA order, like the device creation flag we specified earlier, if you remember. Scaling tells DXGI to scale the buffer's contents to fit the presentation's target size. BufferCount is 2, because we want double buffering. Double buffering is an age-old technique to avoid presenting an image that is being used by the GPU, instead we work on the \"back buffer\", while the GPU is happy presenting the \"front buffer\", then, as soon as we are done with the back buffer, we swap front and back, and begin working on the former front buffer present that one and render to the other one again in the meantime. That process is supposed to reduce flicker or tearing. SwapEffect specifies if the contents of the back buffer should be preserved or discarded after a swap, here we don't care about preserving the back buffer so we just discard everything. AlphaMode specifies how DXGI should handle transparency, we don't care about that (yet), so we'll just say it's unspecified and rely on default behaviour if ( ! CreateSwapchainResources ()) { return false ; } return true ; And the last bits of the Initialize method. We need to create a few more things. Those are based on the swapchain, hence their name. These resources need to be destroyed and recreated whenever we want to resize the window. When that happens, the swapchain needs to be resized as well (since that is a prameter in its descriptor as you can see above) bool HelloD3D11Application::CreateSwapchainResources () { ComPtr < ID3D11Texture2D > backBuffer = nullptr ; if ( FAILED ( _swapChain -> GetBuffer ( 0 , IID_PPV_ARGS ( & backBuffer )))) { std :: cout << \"D3D11: Failed to get Back Buffer from the SwapChain \\n \" ; return false ; } if ( FAILED ( _device -> CreateRenderTargetView ( backBuffer . Get (), nullptr , & _renderTarget ))) { std :: cout << \"D3D11: Failed to create RTV from Back Buffer \\n \" ; return false ; } return true ; } When we render things, the GPU simply writes color values to a texture, which you can picture as a buffer which holds color information Swapchain is a container to manage those buffers we want to present on screen. To do that we have to create a special kind of texture called a \"Render Target View\" or an RTV. First off we have to grab a texture from the swapchain's main buffer (index 0), from that texture, we now have create an RTV from that, which specifies the subresource of the texture that we will be drawing to. We wont keep the actual texture around, we just need the render target view, which we will refer to as render target. void HelloD3D11Application::DestroySwapchainResources () { _renderTarget . Reset (); } The render target needs to be disposed when we want to resize (or cleanup in general), it will be recreated via CreateSwapchainResources when we resize the window as shown here: void HelloD3D11Application::OnResize ( const int32_t width , const int32_t height ) { Application :: OnResize ( width , height ); _deviceContext -> Flush (); DestroySwapchainResources (); if ( FAILED ( _swapChain -> ResizeBuffers ( 0 , width , height , DXGI_FORMAT :: DXGI_FORMAT_B8G8R8A8_UNORM , 0 ))) { std :: cout << \"D3D11: Failed to recreate SwapChain buffers \\n \" ; return ; } CreateSwapchainResources (); } When we resize, let the base application know about it, and make sure the device context has done all its work ( Flush ) Before we can resize the swapchain, make sure all resources based on it are disposed. Afterwards recreate them with the new dimensions of the swapchain void HelloD3D11Application::Render () { D3D11_VIEWPORT viewport = {}; viewport . TopLeftX = 0 ; viewport . TopLeftY = 0 ; viewport . Width = GetWindowWidth (); viewport . Height = GetWindowHeight (); viewport . MinDepth = 0.0f ; viewport . MaxDepth = 1.0f ; constexpr float clearColor [] = { 0.1f , 0.1f , 0.1f , 1.0f }; _deviceContext -> ClearRenderTargetView ( _renderTarget . Get (), clearColor ); _deviceContext -> RSSetViewports ( 1 , & viewport ); _deviceContext -> OMSetRenderTargets ( 1 , _renderTarget . GetAddressOf (), nullptr ); _swapChain -> Present ( 1 , 0 ); } Now we can actually use those things we have created before. We just set it up so that we tell D3D11 that we want to render into the render target, and when we clear we want to use a dark gray. We also have to specify an area in form of a rectangle, in this case, its equivalent to the window size. Last but not least, we Present the content of the swapchain to the window, using Present . The first argument defines which vblanks to synchronize with presentation, 0 means: no synchronization (unlimited FPS), 1 means: sync every v-blank (regular v-sync), 2 means: sync every other v-blank and so on, up to 4. The second are optional flags, we don't need them so 0 is passed. Application also defines an abstract method Update which we have to define here as well, so we will add: void HelloD3D11Application::Update () { } But keep it empty for now. Same applies for Application 's Load method. bool HelloD3D11Application::Load () { return true ; } Finally we need to modify Appplication.hpp and Application.cpp . Since we want to handle resizing as well.","title":"HelloD3D11.cpp"},{"location":"1-introduction/1-1-getting-started/1-1-2-hello-d3d11/#applicationhpp","text":"Find protected: and add the following lines static void HandleResize ( GLFWwindow * window , const int32_t width , const int32_t height ); virtual void OnResize ( const int32_t width , const int32_t height ); [[ nodiscard ]] GLFWwindow * GetWindow () const ; [[ nodiscard ]] int32_t GetWindowWidth () const ; [[ nodiscard ]] int32_t GetWindowHeight () const ; HandleResize will be the callback from GLFW which handles resize events and OnResize will be execute when GLFW runs HandleResize, so that we can handle our custom things we want to execute when resizing the window, like changing the size of the swapchain in our example. GetWindow() is used to derive the actual native window handle from, which is needed when we create the swapchain. GetWindowWidth() and GetWindowHeight() do what they say :) Also required for swapchain creation.","title":"Application.hpp"},{"location":"1-introduction/1-1-getting-started/1-1-2-hello-d3d11/#applicationcpp","text":"Add the following lines void Application::OnResize ( const int32_t width , const int32_t height ) { _width = width ; _height = height ; } void Application::HandleResize ( GLFWwindow * window , const int32_t width , const int32_t height ) { Application & application = * static_cast < Application *> ( glfwGetWindowUserPointer ( window )); application . OnResize ( width , height ); } GLFWwindow * Application::GetWindow () const { return _window ; } int32_t Application::GetWindowWidth () const { return _width ; } int32_t Application::GetWindowHeight () const { return _height ; } Find the Initialize method and add the following two lines before return true; glfwSetWindowUserPointer ( _window , this ); glfwSetFramebufferSizeCallback ( _window , HandleResize ); glfwSetWindowUserPointer will set our application instance as a custom variable, so that we can retrieve it using glfwGetWindowUserPointer in the HandleResize callback. glfwSetFramebufferSizeCallback will tell GLFW what to do when we resize the window, in this case execute HandleResize which will fetch our application instance and all OnResize on it, where we can handle resizing in our application code. Project on GitHub Next chapter","title":"Application.cpp"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/","text":"Hello Triangle \u00b6 In the last chapter we initialized core components of D3D11 and DXGI such as the Device and the SwapChain, but simply clearing the Window with some color is pretty boring. This time we'll be drawing our first triangle with a nice froge-like color. The Pipeline \u00b6 The fundamental part of all graphic APIs is the \"Graphics Pipeline\". Everything from a single triangle, textured frog or the whole Elden Ring map goes through this pipeline. It is a series of functions that either exist in hardware, can be configured or are fully programmable. It transforms everything we draw in 3D space to the 2D space that is our monitor. All the steps in the graphics pipeline go from top to bottom and are shown below. As you can see, each stage in the pipeline takes in the previous stage's output as the input, the rectangle blocks are pipeline stages that are not programmable but are configurable, while the rounded rectangle blocks are stages that are fully programmable. To draw most of the things throughout this series we'll mostly need these stages: Input Assembler, Vertex Shader and the Pixel Shader, Output Merger. The Vertex and Pixel shaders are fully programmable and we'll write a very basic program for them. The other two stages are not programmable but they are fairly easy to understand and configure, the Input Assembler is responsible for processing the vertices in an eventual vertex buffer into the primitive of our choice, which is of course, triangles in our case, and sending this processed output to the Vertex Shader. The Output Merger instead is responsible for combining the values written by the pixel shader, may that be depth, color or other things, into the one or more render targets that we provide to the OM, we only have one render target for now. Vertex Shader \u00b6 The Vertex Shader is the stage where our vertices are processed however we want, although we don't do much processing here, and in the end they're transformed to screen-space coordinates The vertices are usually read from a Vertex Buffer which are laid out in a particular way. The vertex shader will be run however many times we tell it to run, which is specified in the first parameter of ID3D11DeviceContext::Draw() (more on this later), for instance if we call Draw(3, 0) , the vertex shader will run 3 times. Since we only want to draw a triangle, we don't need to do much processing, we can just provide the input vertices as the output. The vertex buffer can be omitted, for example if we want to draw a full screen triangle, instead of creating a vertex buffer, for simplicity we can just hardcode the vertices in the vertex shader without having to bind a vertex buffer. Let's look at our basic vertex shader for this section: Main.vs.hlsl \u00b6 struct VSInput { float3 position : POSITION ; float3 color : COLOR0 ; }; struct VSOutput { float4 position : SV_Position ; float3 color : COLOR0 ; }; VSOutput Main ( VSInput input ) { VSOutput output = ( VSOutput ) 0 ; output . position = float4 ( input . position , 1.0 ); output . color = input . color ; return output ; } First off, we define 2 types, VSInput and VSOutput which represent the vertex shader's input and output. The input is 2, float3 (vector of 3 float components), the first is the \"position\" field, which are coordinates ranging from [-1.0, 1.0], if the values are outside this range they are clipped, and we won't see them on screen. The second is the \"color\" field, which we also pass as the output of this stage onto the pixel shader. Notice how all our fields have a colon and some identifier attached to them, these are \"semantics\". Semantics that are preceded by SV are called \"system-value semantics\" and their meaning and usage is defined by D3D11. SV_Position for example means that the field position will be used by D3D11 as the actual output of the vertex shader. Everything else are \"user defined semantics\" and their naming is up to us. These are used to pass data between shader stages. Then we have our VSOutput , which has our vertices in the first field position and our color in the second field color . Finally we have our main function, which takes in a single parameter which is our input in the form of VSInput , and returns our output in the form of a VSOutput . Since we don't do any processing, we simply make a new instance of VSOutput , initialize it all to 0 and forward our input position and color to the output. Pixel Shader \u00b6 The Pixel Shader is the stage where we give the pixels on our render target color, it is invoked for each pixel that is covered by a triangle. We use this stage to apply most of our shading techniques, from basic lighting, to textures and shadows, all the way to physically based rendering. Since we did not specify any shader between the VS and the PS, our input here is the output of the VS, and the output is one or more render targets. Let's look at our Pixel Shader now: Main.ps.hlsl \u00b6 struct PSInput { float4 position : SV_Position ; float3 color : COLOR0 ; }; struct PSOutput { float4 color : SV_Target0 ; }; PSOutput Main ( PSInput input ) { PSOutput output = ( PSOutput ) 0 ; output . color = float4 ( input . color , 1.0 ); return output ; } Here as well we have an input PSInput , and an output PSOutput . Since there aren't any other shaders in between the VS and the PS, the VS's output is the PS's input, the naming might be a bit confusing but that's the gist of it, PSInput should match the VSOutput in vertex shader, this isn't entirely required but not doing so is only advisable if you really know what you are doing. Next we have our output, D3D11 gives us the possibility to write to multiple render targets, but we are not doing that, so we'll just be writing a float4 as our output, which is an RGBA color. Notice how we have another semantic string attached to the color field, this semantic string specifies which render target we want to be writing to, the 0 after SV_Target is the index of our render target, in our case, we have only one so we write SV_Target0 or SV_Target . D3D11 lets us write up to 8 render targets simultaneously from the same pixel shader, those come in handy when implementing more advanced shading techniques, for example a popular technique that uses 4 or more And lastly, our Main function, following the same pattern as in the VS, we have one parameter, the input, and one return value, the output, again we create an instance of PSOutput , initialize everything to 0, and write the color we got from the input, to our output. Compiling shaders \u00b6 Now that we wrote our shader code and saved it somewhere, we have to feed this to the GPU, to do that we'll have our D3DCompiler get to work. First, we will declare some functions that will help us compile our shaders more quickly. HelloTriangle.hpp \u00b6 bool CompileShader ( const std :: wstring_view fileName , const std :: string_view entryPoint , const std :: string_view profile , ComPtr < ID3DBlob >& shaderBlob ) const ; [[ nodiscard ]] ComPtr < ID3D11VertexShader > CreateVertexShader ( const std :: wstring_view fileName , ComPtr < ID3DBlob >& vertexShaderBlob ) const ; [[ nodiscard ]] ComPtr < ID3D11PixelShader > CreatePixelShader ( std :: wstring_view fileName ) const ; In order we have: CompileShader : This function is the core for compiling shaders, it requires 3 input parameters: fileName : is the path of the shader file we want to compile. entryPoint : is the name of the function where the shader begins execution. profile : which is basically the version of HLSL we want to use, the higher the profile number, the more features there are. And one output parameter: shaderBlob : the blob were our compiled code will be stored. A blob is just a fancy buffer which D3D11 can use for specific purposes. Then: CreateVertexShader : This function helps us create specifically a ID3D11VertexShader , it only requires the shader path and a ID3DBlob . We need to pass a blob ourselves because we'll need the VS's blob later. CreatePixelShader : It does the same thing that CreateVertexShader does, except we don't need to pass a ID3DBlob here. Now that we know how our new members look, we will see how we implemented them. HelloTriangle.cpp \u00b6 First things first, let's see CompileShader : CompileShader \u00b6 bool HelloTriangleApplication::CompileShader ( const std :: wstring_view fileName , const std :: string_view entryPoint , const std :: string_view profile , ComPtr < ID3DBlob >& shaderBlob ) const { constexpr UINT compileFlags = D3DCOMPILE_ENABLE_STRICTNESS ; ComPtr < ID3DBlob > tempShaderBlob = nullptr ; ComPtr < ID3DBlob > errorBlob = nullptr ; if ( FAILED ( D3DCompileFromFile ( fileName . data (), nullptr , D3D_COMPILE_STANDARD_FILE_INCLUDE , entryPoint . data (), profile . data (), compileFlags , 0 , & tempShaderBlob , & errorBlob ))) { std :: cout << \"D3D11: Failed to read shader from file \\n \" ; if ( errorBlob != nullptr ) { std :: cout << \"D3D11: With message: \" << static_cast < const char *> ( errorBlob -> GetBufferPointer ()) << \" \\n \" ; } return false ; } shaderBlob = std :: move ( tempShaderBlob ); return true ; } We start by creating two ID3DBlob s, we will need a temporary blob, where we'll load our shader file and an error blob, which will contain our error messages, if any. Then we call for D3DCompileFromFile , it requires quite a lot of parameters so let's go over them one by one in order: pFileName : a UTF-8 string containing the file name of the shader we want to compile. pDefines : optional, basically an array of macros that we want to define. pInclude : optional, a pointer to a ID3DInclude object, it is useful to specify how to handle #include directives in shaders. It is common to just use D3D_COMPILE_STANDARD_FILE_INCLUDE , which is the default handler. pEntrypoint : a string containing the name of the main function in the shader. pTarget : a string containing the Shader Model version to use for this shader. Flags1 : the flags that changes how to compile our shaders, for example we pass D3DCOMPILE_ENABLE_STRICTNESS which makes the compiler stricter in judging our code and disables legacy syntax support. Flags2 : ignored, set to 0. ppCode : output, a pointer to a ID3DBlob* , this is where our compiled code will be stored. ppErrorMsgs : optional, output, a pointer to a ID3DBlob* , this is where the D3D compiler will store our errors, nullptr if everything went fine. Then we do our usual checking, if there were errors, leave the output blob as is and print the error message contained in the blob. Otherwise, move the blob to our output parameter. Now let's see CreateVertexShader and CreatePixelShader : CreateVertexShader \u00b6 HelloTriangleApplication :: ComPtr < ID3D11VertexShader > HelloTriangleApplication :: CreateVertexShader ( const std :: wstring_view fileName , ComPtr < ID3DBlob >& vertexShaderBlob ) const { if ( ! CompileShader ( fileName , \"Main\" , \"vs_5_0\" , vertexShaderBlob )) { return nullptr ; } ComPtr < ID3D11VertexShader > vertexShader ; if ( FAILED ( _device -> CreateVertexShader ( vertexShaderBlob -> GetBufferPointer (), vertexShaderBlob -> GetBufferSize (), nullptr , & vertexShader ))) { std :: cout << \"D3D11: Failed to compile vertex shader \\n \" ; return nullptr ; } return vertexShader ; } As you can see here we are using our helper function CompileShader to avoid repeating ourselves, we are specifying \"Main\" as the entry point of our vertex shader and \"vs_5_0\" as the Shader Model, which means \"Vertex Shader Model 5.0\". After we get our blob successfully, we can create a vertex shader out of it with ID3D11Device::CreateVertexShader , it takes a pointer to a buffer with the compiled code and its size as the input. The resulting vertex shader is the last parameter which is our output. And finally CreatePixelShader \u00b6 HelloTriangleApplication :: ComPtr < ID3D11PixelShader > HelloTriangleApplication :: CreatePixelShader ( const std :: wstring_view fileName ) const { ComPtr < ID3DBlob > pixelShaderBlob = nullptr ; if ( ! CompileShader ( fileName , \"Main\" , \"ps_5_0\" , pixelShaderBlob )) { return nullptr ; } ComPtr < ID3D11PixelShader > pixelShader ; if ( FAILED ( _device -> CreatePixelShader ( pixelShaderBlob -> GetBufferPointer (), pixelShaderBlob -> GetBufferSize (), nullptr , & pixelShader ))) { std :: cout << \"D3D11: Failed to compile pixel shader \\n \" ; return nullptr ; } return pixelShader ; } Pretty much the same thing as CreateVertexShader , the only thing that changes is the profile parameter, from \"vs_5_0\" to \"ps_5_0\" , since we're not compiling a vertex shader now, we have to change this to the \"Pixel Shader Model 5.0\". After all of this, we can now call these functions, in HelloTriangleApplication::Initialize() you should now add: Initialize \u00b6 ComPtr < ID3DBlob > vertexShaderBlob = nullptr ; _vertexShader = CreateVertexShader ( L \"Assets/Shaders/Main.vs.hlsl\" , vertexShaderBlob ); if ( _vertexShader == nullptr ) { return false ; } _pixelShader = CreatePixelShader ( L \"Assets/Shaders/Main.ps.hlsl\" ); if ( _pixelShader == nullptr ) { return false ; } We still have a vertexShaderBlob now, it will be useful to us later, in creating an input layout. Input Layouts \u00b6 We have successfully compiled our shaders now, we need one last thing, an Input Layout . An input layout, is basically the format we want to lay our vertices in our buffers. Since all our vertices we want to give to the GPU must be tightly packed in the same buffer, the Input Assembler needs a way to make sense of our data, this is exactly what an input layout is for. Let's see what input we expect in the vertes shader: struct VSInput { float3 position : POSITION ; float3 color : COLOR0 ; }; The vertex shader expects 2 vectors of 3 components each, for each vertex. We should then create an input layout exactly with this format. First of all, creating a struct in our C++ source with that maps to our VSInput as closely as possible will make our life easier. To do this we'll use DirectXMath which has types that map perfectly to HLSL, both of our inputs are float3 in HLSL, which means that this translates to DirectX::XMFLOAT3 . using Position = DirectX :: XMFLOAT3 ; using Color = DirectX :: XMFLOAT3 ; struct VertexPositionColor { Position position ; Color color ; }; The type aliases help us make this more readable and more easily guess what is what, so obviously the first field is our position vector and the second field is our color vector. Now we can create our Input Layout Description using an array of D3D11_INPUT_ELEMENT_DESC . You can think of each element in this array as describing one field in the VSInput . constexpr D3D11_INPUT_ELEMENT_DESC vertexInputLayoutInfo [] = { { \"POSITION\" , 0 , DXGI_FORMAT :: DXGI_FORMAT_R32G32B32_FLOAT , 0 , offsetof ( VertexPositionColor , position ), D3D11_INPUT_CLASSIFICATION :: D3D11_INPUT_PER_VERTEX_DATA , 0 }, { \"COLOR\" , 0 , DXGI_FORMAT :: DXGI_FORMAT_R32G32B32_FLOAT , 0 , offsetof ( VertexPositionColor , color ), D3D11_INPUT_CLASSIFICATION :: D3D11_INPUT_PER_VERTEX_DATA , 0 }, }; Now let's make sense of what each field means, let's go over one by one in order. SemanticName : let's us refer to a particular field given the string after the colon in HLSL (remember float3 position: POSITION ) SemanticIndex : the index of each semantic, POSITION is equivalent to POSITION0 , where the number at the end is our index, so we'll just pass in 0. Format : the format of this field, basically how many components there are and what type they are, a float3 in HLSL is a vector of 3 floats, each float is 4 bytes wide (or 32 bits), so the format here is DXGI_FORMAT_R32G32B32_FLOAT . InputSlot : we'll see about this later. AlignedByteOffset : the offset of this field, in bytes; this is our first field so there is no offset, but the COLOR one for example, will have an offset of 12 bytes. InputSlotClass : The rate of input either per-vertex or per-instance, we don't care about instances right now so we'll set this to PER_VERTEX. InstanceDataStepRate : if InputSlotClass was PER_INSTANCE, this would mean how many instances should be drawn with the same data; this is 0 since we don't care about this. Hopefully it makes a bit more sense now, all we have to do is create the input layout using this data: if ( FAILED ( _device -> CreateInputLayout ( vertexInputLayoutInfo , _countof ( vertexInputLayoutInfo ), vertexShaderBlob -> GetBufferPointer (), vertexShaderBlob -> GetBufferSize (), & _vertexLayout ))) { std :: cout << \"D3D11: Failed to create default vertex input layout \\n \" ; return false ; } As usual we follow the same pattern, we pass in our vertexInputLayoutInfo that we just created and its size, we also need to pass our vertex blob pointer and size, and finally our output parameter which is our input layout. Now all we have to do is create a vertex buffer (don't worry it's really easy) and issue our first Draw command! Error Image showing stride and offset? Vertex Buffers \u00b6 Vertex Buffers might seem hard at first, but they're really nothing more than a buffer that resides in our device's memory, which means really fast access. This buffer will be then bound and read by the vertex shader. Creating a vertex buffer is also really easy, first of all we have to make some data to put in our buffer, since we want to draw a triangle, we will be creating 3 vertices using our VertexPositionColor struct. constexpr VertexPositionColor vertices [] = { { Position { 0.0f , 0.5f , 0.0f }, Color { 0.25f , 0.39f , 0.19f } }, { Position { 0.5f , -0.5f , 0.0f }, Color { 0.44f , 0.75f , 0.35f } }, { Position { -0.5f , -0.5f , 0.0f }, Color { 0.38f , 0.55f , 0.20f } }, }; There we go, remember, the position coordinates we have to give to the vertex shader must be in range [-1.0, 1.0], otherwise we won't be able to see that vertex. We are storing these coordinates that form a triangle here, we're also storing a color for each vertex, since they will be interpolated by our pixel shader. If you want you can try to visualize the triangle, take a piece of paper, draw a Cartesian Plane , draw 3 points and connect the dots with these coordinates. Now that we have the data, let's store this on our vertex buffer: D3D11_BUFFER_DESC bufferInfo = {}; bufferInfo . ByteWidth = sizeof ( vertices ); bufferInfo . Usage = D3D11_USAGE :: D3D11_USAGE_IMMUTABLE ; bufferInfo . BindFlags = D3D11_BIND_FLAG :: D3D11_BIND_VERTEX_BUFFER ; D3D11_SUBRESOURCE_DATA resourceData = {}; resourceData . pSysMem = vertices ; if ( FAILED ( _device -> CreateBuffer ( & bufferInfo , & resourceData , & _triangleVertices ))) { std :: cout << \"D3D11: Failed to create triangle vertex buffer \\n \" ; return false ; } We begin by filling a bufferInfo descriptor for our buffer, we specify how many bytes we want, since this buffer will never change, for the Usage we specify: D3D11_USAGE_IMMUTABLE , this lets D3D11 put this data a close as possible to the GPU, finally we specify how we want to use this buffer, we want this to be a vertex buffer, so for the BindFlags we give: D3D11_BIND_VERTEX_BUFFER . And finally we create a resourceData , and populate the only field we care about: pSysMem , which is a pointer to our vertices which are currently in system RAM. Then we issue the creation of the buffer using CreateBuffer , using the informations we collected until now. Drawing our triangle \u00b6 Finally we have reached the moment of truth, in our Render function we will add a few things: _deviceContext -> IASetInputLayout ( _vertexLayout . Get ()); This sets the input layout we want to use. _deviceContext -> IASetVertexBuffers ( 0 , 1 , _triangleVertices . GetAddressOf (), & vertexStride , & vertexOffset ); Then we go ahead and bind our vertex buffer. _deviceContext -> IASetPrimitiveTopology ( D3D11_PRIMITIVE_TOPOLOGY :: D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST ); This sets how the Input Assembler should interpret the vertex data, since we want to draw triangles, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST is the right flag for us. _deviceContext -> VSSetShader ( _vertexShader . Get (), nullptr , 0 ); _deviceContext -> PSSetShader ( _pixelShader . Get (), nullptr , 0 ); Setting the vertex and pixel shader here. I suggest to put PSSetShader after RSSetViewports , since it will maintain the pipeline order, it doesn't have any performance or correctness implications, it will just help you remember better which stage comes after which. _deviceContext -> Draw ( 3 , 0 ); And finally, tell the GPU to draw 3 vertices, this will invoke the vertex shader 3 times, and it will successfully process the 3 vertices we put in our vertex buffer. Finally let's review all the commands we issue in Render _deviceContext -> IASetInputLayout ( _vertexLayout . Get ()); _deviceContext -> IASetVertexBuffers ( 0 , 1 , _triangleVertices . GetAddressOf (), & vertexStride , & vertexOffset ); _deviceContext -> IASetPrimitiveTopology ( D3D11_PRIMITIVE_TOPOLOGY :: D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST ); _deviceContext -> VSSetShader ( _vertexShader . Get (), nullptr , 0 ); _deviceContext -> RSSetViewports ( 1 , & viewport ); _deviceContext -> PSSetShader ( _pixelShader . Get (), nullptr , 0 ); _deviceContext -> OMSetRenderTargets ( 1 , _renderTarget . GetAddressOf (), nullptr ); As you can see, we go through the pipeline in an orderly fashion, and although we don't use all the stages, we can see the top-to-bottom execution of the stages, IA (Input Assembler) -> VS (Vertex Shader) -> RS (Rasterizer Stage) -> PS (Pixel Shader) -> OM (Output Merger). You should now be able to run this and see your first triangle! Error Provide picture of window with triangle Project on GitHub Next chapter","title":"Hello Triangle"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#hello-triangle","text":"In the last chapter we initialized core components of D3D11 and DXGI such as the Device and the SwapChain, but simply clearing the Window with some color is pretty boring. This time we'll be drawing our first triangle with a nice froge-like color.","title":"Hello Triangle"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#the-pipeline","text":"The fundamental part of all graphic APIs is the \"Graphics Pipeline\". Everything from a single triangle, textured frog or the whole Elden Ring map goes through this pipeline. It is a series of functions that either exist in hardware, can be configured or are fully programmable. It transforms everything we draw in 3D space to the 2D space that is our monitor. All the steps in the graphics pipeline go from top to bottom and are shown below. As you can see, each stage in the pipeline takes in the previous stage's output as the input, the rectangle blocks are pipeline stages that are not programmable but are configurable, while the rounded rectangle blocks are stages that are fully programmable. To draw most of the things throughout this series we'll mostly need these stages: Input Assembler, Vertex Shader and the Pixel Shader, Output Merger. The Vertex and Pixel shaders are fully programmable and we'll write a very basic program for them. The other two stages are not programmable but they are fairly easy to understand and configure, the Input Assembler is responsible for processing the vertices in an eventual vertex buffer into the primitive of our choice, which is of course, triangles in our case, and sending this processed output to the Vertex Shader. The Output Merger instead is responsible for combining the values written by the pixel shader, may that be depth, color or other things, into the one or more render targets that we provide to the OM, we only have one render target for now.","title":"The Pipeline"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#vertex-shader","text":"The Vertex Shader is the stage where our vertices are processed however we want, although we don't do much processing here, and in the end they're transformed to screen-space coordinates The vertices are usually read from a Vertex Buffer which are laid out in a particular way. The vertex shader will be run however many times we tell it to run, which is specified in the first parameter of ID3D11DeviceContext::Draw() (more on this later), for instance if we call Draw(3, 0) , the vertex shader will run 3 times. Since we only want to draw a triangle, we don't need to do much processing, we can just provide the input vertices as the output. The vertex buffer can be omitted, for example if we want to draw a full screen triangle, instead of creating a vertex buffer, for simplicity we can just hardcode the vertices in the vertex shader without having to bind a vertex buffer. Let's look at our basic vertex shader for this section:","title":"Vertex Shader"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#mainvshlsl","text":"struct VSInput { float3 position : POSITION ; float3 color : COLOR0 ; }; struct VSOutput { float4 position : SV_Position ; float3 color : COLOR0 ; }; VSOutput Main ( VSInput input ) { VSOutput output = ( VSOutput ) 0 ; output . position = float4 ( input . position , 1.0 ); output . color = input . color ; return output ; } First off, we define 2 types, VSInput and VSOutput which represent the vertex shader's input and output. The input is 2, float3 (vector of 3 float components), the first is the \"position\" field, which are coordinates ranging from [-1.0, 1.0], if the values are outside this range they are clipped, and we won't see them on screen. The second is the \"color\" field, which we also pass as the output of this stage onto the pixel shader. Notice how all our fields have a colon and some identifier attached to them, these are \"semantics\". Semantics that are preceded by SV are called \"system-value semantics\" and their meaning and usage is defined by D3D11. SV_Position for example means that the field position will be used by D3D11 as the actual output of the vertex shader. Everything else are \"user defined semantics\" and their naming is up to us. These are used to pass data between shader stages. Then we have our VSOutput , which has our vertices in the first field position and our color in the second field color . Finally we have our main function, which takes in a single parameter which is our input in the form of VSInput , and returns our output in the form of a VSOutput . Since we don't do any processing, we simply make a new instance of VSOutput , initialize it all to 0 and forward our input position and color to the output.","title":"Main.vs.hlsl"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#pixel-shader","text":"The Pixel Shader is the stage where we give the pixels on our render target color, it is invoked for each pixel that is covered by a triangle. We use this stage to apply most of our shading techniques, from basic lighting, to textures and shadows, all the way to physically based rendering. Since we did not specify any shader between the VS and the PS, our input here is the output of the VS, and the output is one or more render targets. Let's look at our Pixel Shader now:","title":"Pixel Shader"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#mainpshlsl","text":"struct PSInput { float4 position : SV_Position ; float3 color : COLOR0 ; }; struct PSOutput { float4 color : SV_Target0 ; }; PSOutput Main ( PSInput input ) { PSOutput output = ( PSOutput ) 0 ; output . color = float4 ( input . color , 1.0 ); return output ; } Here as well we have an input PSInput , and an output PSOutput . Since there aren't any other shaders in between the VS and the PS, the VS's output is the PS's input, the naming might be a bit confusing but that's the gist of it, PSInput should match the VSOutput in vertex shader, this isn't entirely required but not doing so is only advisable if you really know what you are doing. Next we have our output, D3D11 gives us the possibility to write to multiple render targets, but we are not doing that, so we'll just be writing a float4 as our output, which is an RGBA color. Notice how we have another semantic string attached to the color field, this semantic string specifies which render target we want to be writing to, the 0 after SV_Target is the index of our render target, in our case, we have only one so we write SV_Target0 or SV_Target . D3D11 lets us write up to 8 render targets simultaneously from the same pixel shader, those come in handy when implementing more advanced shading techniques, for example a popular technique that uses 4 or more And lastly, our Main function, following the same pattern as in the VS, we have one parameter, the input, and one return value, the output, again we create an instance of PSOutput , initialize everything to 0, and write the color we got from the input, to our output.","title":"Main.ps.hlsl"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#compiling-shaders","text":"Now that we wrote our shader code and saved it somewhere, we have to feed this to the GPU, to do that we'll have our D3DCompiler get to work. First, we will declare some functions that will help us compile our shaders more quickly.","title":"Compiling shaders"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#hellotrianglehpp","text":"bool CompileShader ( const std :: wstring_view fileName , const std :: string_view entryPoint , const std :: string_view profile , ComPtr < ID3DBlob >& shaderBlob ) const ; [[ nodiscard ]] ComPtr < ID3D11VertexShader > CreateVertexShader ( const std :: wstring_view fileName , ComPtr < ID3DBlob >& vertexShaderBlob ) const ; [[ nodiscard ]] ComPtr < ID3D11PixelShader > CreatePixelShader ( std :: wstring_view fileName ) const ; In order we have: CompileShader : This function is the core for compiling shaders, it requires 3 input parameters: fileName : is the path of the shader file we want to compile. entryPoint : is the name of the function where the shader begins execution. profile : which is basically the version of HLSL we want to use, the higher the profile number, the more features there are. And one output parameter: shaderBlob : the blob were our compiled code will be stored. A blob is just a fancy buffer which D3D11 can use for specific purposes. Then: CreateVertexShader : This function helps us create specifically a ID3D11VertexShader , it only requires the shader path and a ID3DBlob . We need to pass a blob ourselves because we'll need the VS's blob later. CreatePixelShader : It does the same thing that CreateVertexShader does, except we don't need to pass a ID3DBlob here. Now that we know how our new members look, we will see how we implemented them.","title":"HelloTriangle.hpp"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#hellotrianglecpp","text":"First things first, let's see CompileShader :","title":"HelloTriangle.cpp"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#compileshader","text":"bool HelloTriangleApplication::CompileShader ( const std :: wstring_view fileName , const std :: string_view entryPoint , const std :: string_view profile , ComPtr < ID3DBlob >& shaderBlob ) const { constexpr UINT compileFlags = D3DCOMPILE_ENABLE_STRICTNESS ; ComPtr < ID3DBlob > tempShaderBlob = nullptr ; ComPtr < ID3DBlob > errorBlob = nullptr ; if ( FAILED ( D3DCompileFromFile ( fileName . data (), nullptr , D3D_COMPILE_STANDARD_FILE_INCLUDE , entryPoint . data (), profile . data (), compileFlags , 0 , & tempShaderBlob , & errorBlob ))) { std :: cout << \"D3D11: Failed to read shader from file \\n \" ; if ( errorBlob != nullptr ) { std :: cout << \"D3D11: With message: \" << static_cast < const char *> ( errorBlob -> GetBufferPointer ()) << \" \\n \" ; } return false ; } shaderBlob = std :: move ( tempShaderBlob ); return true ; } We start by creating two ID3DBlob s, we will need a temporary blob, where we'll load our shader file and an error blob, which will contain our error messages, if any. Then we call for D3DCompileFromFile , it requires quite a lot of parameters so let's go over them one by one in order: pFileName : a UTF-8 string containing the file name of the shader we want to compile. pDefines : optional, basically an array of macros that we want to define. pInclude : optional, a pointer to a ID3DInclude object, it is useful to specify how to handle #include directives in shaders. It is common to just use D3D_COMPILE_STANDARD_FILE_INCLUDE , which is the default handler. pEntrypoint : a string containing the name of the main function in the shader. pTarget : a string containing the Shader Model version to use for this shader. Flags1 : the flags that changes how to compile our shaders, for example we pass D3DCOMPILE_ENABLE_STRICTNESS which makes the compiler stricter in judging our code and disables legacy syntax support. Flags2 : ignored, set to 0. ppCode : output, a pointer to a ID3DBlob* , this is where our compiled code will be stored. ppErrorMsgs : optional, output, a pointer to a ID3DBlob* , this is where the D3D compiler will store our errors, nullptr if everything went fine. Then we do our usual checking, if there were errors, leave the output blob as is and print the error message contained in the blob. Otherwise, move the blob to our output parameter. Now let's see CreateVertexShader and CreatePixelShader :","title":"CompileShader"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#createvertexshader","text":"HelloTriangleApplication :: ComPtr < ID3D11VertexShader > HelloTriangleApplication :: CreateVertexShader ( const std :: wstring_view fileName , ComPtr < ID3DBlob >& vertexShaderBlob ) const { if ( ! CompileShader ( fileName , \"Main\" , \"vs_5_0\" , vertexShaderBlob )) { return nullptr ; } ComPtr < ID3D11VertexShader > vertexShader ; if ( FAILED ( _device -> CreateVertexShader ( vertexShaderBlob -> GetBufferPointer (), vertexShaderBlob -> GetBufferSize (), nullptr , & vertexShader ))) { std :: cout << \"D3D11: Failed to compile vertex shader \\n \" ; return nullptr ; } return vertexShader ; } As you can see here we are using our helper function CompileShader to avoid repeating ourselves, we are specifying \"Main\" as the entry point of our vertex shader and \"vs_5_0\" as the Shader Model, which means \"Vertex Shader Model 5.0\". After we get our blob successfully, we can create a vertex shader out of it with ID3D11Device::CreateVertexShader , it takes a pointer to a buffer with the compiled code and its size as the input. The resulting vertex shader is the last parameter which is our output. And finally","title":"CreateVertexShader"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#createpixelshader","text":"HelloTriangleApplication :: ComPtr < ID3D11PixelShader > HelloTriangleApplication :: CreatePixelShader ( const std :: wstring_view fileName ) const { ComPtr < ID3DBlob > pixelShaderBlob = nullptr ; if ( ! CompileShader ( fileName , \"Main\" , \"ps_5_0\" , pixelShaderBlob )) { return nullptr ; } ComPtr < ID3D11PixelShader > pixelShader ; if ( FAILED ( _device -> CreatePixelShader ( pixelShaderBlob -> GetBufferPointer (), pixelShaderBlob -> GetBufferSize (), nullptr , & pixelShader ))) { std :: cout << \"D3D11: Failed to compile pixel shader \\n \" ; return nullptr ; } return pixelShader ; } Pretty much the same thing as CreateVertexShader , the only thing that changes is the profile parameter, from \"vs_5_0\" to \"ps_5_0\" , since we're not compiling a vertex shader now, we have to change this to the \"Pixel Shader Model 5.0\". After all of this, we can now call these functions, in HelloTriangleApplication::Initialize() you should now add:","title":"CreatePixelShader"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#initialize","text":"ComPtr < ID3DBlob > vertexShaderBlob = nullptr ; _vertexShader = CreateVertexShader ( L \"Assets/Shaders/Main.vs.hlsl\" , vertexShaderBlob ); if ( _vertexShader == nullptr ) { return false ; } _pixelShader = CreatePixelShader ( L \"Assets/Shaders/Main.ps.hlsl\" ); if ( _pixelShader == nullptr ) { return false ; } We still have a vertexShaderBlob now, it will be useful to us later, in creating an input layout.","title":"Initialize"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#input-layouts","text":"We have successfully compiled our shaders now, we need one last thing, an Input Layout . An input layout, is basically the format we want to lay our vertices in our buffers. Since all our vertices we want to give to the GPU must be tightly packed in the same buffer, the Input Assembler needs a way to make sense of our data, this is exactly what an input layout is for. Let's see what input we expect in the vertes shader: struct VSInput { float3 position : POSITION ; float3 color : COLOR0 ; }; The vertex shader expects 2 vectors of 3 components each, for each vertex. We should then create an input layout exactly with this format. First of all, creating a struct in our C++ source with that maps to our VSInput as closely as possible will make our life easier. To do this we'll use DirectXMath which has types that map perfectly to HLSL, both of our inputs are float3 in HLSL, which means that this translates to DirectX::XMFLOAT3 . using Position = DirectX :: XMFLOAT3 ; using Color = DirectX :: XMFLOAT3 ; struct VertexPositionColor { Position position ; Color color ; }; The type aliases help us make this more readable and more easily guess what is what, so obviously the first field is our position vector and the second field is our color vector. Now we can create our Input Layout Description using an array of D3D11_INPUT_ELEMENT_DESC . You can think of each element in this array as describing one field in the VSInput . constexpr D3D11_INPUT_ELEMENT_DESC vertexInputLayoutInfo [] = { { \"POSITION\" , 0 , DXGI_FORMAT :: DXGI_FORMAT_R32G32B32_FLOAT , 0 , offsetof ( VertexPositionColor , position ), D3D11_INPUT_CLASSIFICATION :: D3D11_INPUT_PER_VERTEX_DATA , 0 }, { \"COLOR\" , 0 , DXGI_FORMAT :: DXGI_FORMAT_R32G32B32_FLOAT , 0 , offsetof ( VertexPositionColor , color ), D3D11_INPUT_CLASSIFICATION :: D3D11_INPUT_PER_VERTEX_DATA , 0 }, }; Now let's make sense of what each field means, let's go over one by one in order. SemanticName : let's us refer to a particular field given the string after the colon in HLSL (remember float3 position: POSITION ) SemanticIndex : the index of each semantic, POSITION is equivalent to POSITION0 , where the number at the end is our index, so we'll just pass in 0. Format : the format of this field, basically how many components there are and what type they are, a float3 in HLSL is a vector of 3 floats, each float is 4 bytes wide (or 32 bits), so the format here is DXGI_FORMAT_R32G32B32_FLOAT . InputSlot : we'll see about this later. AlignedByteOffset : the offset of this field, in bytes; this is our first field so there is no offset, but the COLOR one for example, will have an offset of 12 bytes. InputSlotClass : The rate of input either per-vertex or per-instance, we don't care about instances right now so we'll set this to PER_VERTEX. InstanceDataStepRate : if InputSlotClass was PER_INSTANCE, this would mean how many instances should be drawn with the same data; this is 0 since we don't care about this. Hopefully it makes a bit more sense now, all we have to do is create the input layout using this data: if ( FAILED ( _device -> CreateInputLayout ( vertexInputLayoutInfo , _countof ( vertexInputLayoutInfo ), vertexShaderBlob -> GetBufferPointer (), vertexShaderBlob -> GetBufferSize (), & _vertexLayout ))) { std :: cout << \"D3D11: Failed to create default vertex input layout \\n \" ; return false ; } As usual we follow the same pattern, we pass in our vertexInputLayoutInfo that we just created and its size, we also need to pass our vertex blob pointer and size, and finally our output parameter which is our input layout. Now all we have to do is create a vertex buffer (don't worry it's really easy) and issue our first Draw command! Error Image showing stride and offset?","title":"Input Layouts"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#vertex-buffers","text":"Vertex Buffers might seem hard at first, but they're really nothing more than a buffer that resides in our device's memory, which means really fast access. This buffer will be then bound and read by the vertex shader. Creating a vertex buffer is also really easy, first of all we have to make some data to put in our buffer, since we want to draw a triangle, we will be creating 3 vertices using our VertexPositionColor struct. constexpr VertexPositionColor vertices [] = { { Position { 0.0f , 0.5f , 0.0f }, Color { 0.25f , 0.39f , 0.19f } }, { Position { 0.5f , -0.5f , 0.0f }, Color { 0.44f , 0.75f , 0.35f } }, { Position { -0.5f , -0.5f , 0.0f }, Color { 0.38f , 0.55f , 0.20f } }, }; There we go, remember, the position coordinates we have to give to the vertex shader must be in range [-1.0, 1.0], otherwise we won't be able to see that vertex. We are storing these coordinates that form a triangle here, we're also storing a color for each vertex, since they will be interpolated by our pixel shader. If you want you can try to visualize the triangle, take a piece of paper, draw a Cartesian Plane , draw 3 points and connect the dots with these coordinates. Now that we have the data, let's store this on our vertex buffer: D3D11_BUFFER_DESC bufferInfo = {}; bufferInfo . ByteWidth = sizeof ( vertices ); bufferInfo . Usage = D3D11_USAGE :: D3D11_USAGE_IMMUTABLE ; bufferInfo . BindFlags = D3D11_BIND_FLAG :: D3D11_BIND_VERTEX_BUFFER ; D3D11_SUBRESOURCE_DATA resourceData = {}; resourceData . pSysMem = vertices ; if ( FAILED ( _device -> CreateBuffer ( & bufferInfo , & resourceData , & _triangleVertices ))) { std :: cout << \"D3D11: Failed to create triangle vertex buffer \\n \" ; return false ; } We begin by filling a bufferInfo descriptor for our buffer, we specify how many bytes we want, since this buffer will never change, for the Usage we specify: D3D11_USAGE_IMMUTABLE , this lets D3D11 put this data a close as possible to the GPU, finally we specify how we want to use this buffer, we want this to be a vertex buffer, so for the BindFlags we give: D3D11_BIND_VERTEX_BUFFER . And finally we create a resourceData , and populate the only field we care about: pSysMem , which is a pointer to our vertices which are currently in system RAM. Then we issue the creation of the buffer using CreateBuffer , using the informations we collected until now.","title":"Vertex Buffers"},{"location":"1-introduction/1-1-getting-started/1-1-3-hello-triangle/#drawing-our-triangle","text":"Finally we have reached the moment of truth, in our Render function we will add a few things: _deviceContext -> IASetInputLayout ( _vertexLayout . Get ()); This sets the input layout we want to use. _deviceContext -> IASetVertexBuffers ( 0 , 1 , _triangleVertices . GetAddressOf (), & vertexStride , & vertexOffset ); Then we go ahead and bind our vertex buffer. _deviceContext -> IASetPrimitiveTopology ( D3D11_PRIMITIVE_TOPOLOGY :: D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST ); This sets how the Input Assembler should interpret the vertex data, since we want to draw triangles, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST is the right flag for us. _deviceContext -> VSSetShader ( _vertexShader . Get (), nullptr , 0 ); _deviceContext -> PSSetShader ( _pixelShader . Get (), nullptr , 0 ); Setting the vertex and pixel shader here. I suggest to put PSSetShader after RSSetViewports , since it will maintain the pipeline order, it doesn't have any performance or correctness implications, it will just help you remember better which stage comes after which. _deviceContext -> Draw ( 3 , 0 ); And finally, tell the GPU to draw 3 vertices, this will invoke the vertex shader 3 times, and it will successfully process the 3 vertices we put in our vertex buffer. Finally let's review all the commands we issue in Render _deviceContext -> IASetInputLayout ( _vertexLayout . Get ()); _deviceContext -> IASetVertexBuffers ( 0 , 1 , _triangleVertices . GetAddressOf (), & vertexStride , & vertexOffset ); _deviceContext -> IASetPrimitiveTopology ( D3D11_PRIMITIVE_TOPOLOGY :: D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST ); _deviceContext -> VSSetShader ( _vertexShader . Get (), nullptr , 0 ); _deviceContext -> RSSetViewports ( 1 , & viewport ); _deviceContext -> PSSetShader ( _pixelShader . Get (), nullptr , 0 ); _deviceContext -> OMSetRenderTargets ( 1 , _renderTarget . GetAddressOf (), nullptr ); As you can see, we go through the pipeline in an orderly fashion, and although we don't use all the stages, we can see the top-to-bottom execution of the stages, IA (Input Assembler) -> VS (Vertex Shader) -> RS (Rasterizer Stage) -> PS (Pixel Shader) -> OM (Output Merger). You should now be able to run this and see your first triangle! Error Provide picture of window with triangle Project on GitHub Next chapter","title":"Drawing our triangle"},{"location":"1-introduction/1-1-getting-started/1-1-4-abstractions/","text":"Abstractions and Quality of Life improvements \u00b6 Before we move on, we are going to change a few things. When you write software you dont always want all your code in one spot, one method or one class, but split it up and separate where it makes sense to do so. This is always a good exercise in projects which are getting a bit bigger, and this project will be getting bigger, since we have to cover a lot of things a lot of components will be involved. From now onwards we will explain everything you need to know to move forward in the usual way. What needs to be added and where, along with the explanations. We will also guide you what you have to add on top of all that. In the end we will have a cleaner structure of the whole thing, while still maintaining a way to find your self around within the project. Lets start: ComPtr \u00b6 You might remember this class HelloTriangleApplication final : public Application { template < typename T > using ComPtr = Microsoft :: WRL :: ComPtr < T > ; public : We will move this type alias into a separate header, so that other components which rely on ComPtr (and make use of the shorter typename). Create a new file in the project and call it Definitions.hpp . It should look like this #pragma once #include <wrl/client.h> namespace WRL = Microsoft :: WRL ; And make sure you include it. Then rename the ComPtr<> locations from ComPtr < ID3D11Device > _device = nullptr ; to WRL :: ComPtr < ID3D11Device > _device = nullptr ; and all the others accordingly. VertexType \u00b6 Next step, create a new file called VertexType.hpp and make sure to include it in HelloTriangleApplication.cpp Then move using Position = DirectX :: XMFLOAT3 ; using Color = DirectX :: XMFLOAT3 ; struct VertexPositionColor { Position position ; Color color ; }; from HelloTriangleApplication.cpp into the new VertexType.hpp Should look like #pragma once #include <DirectXMath.h> enum class VertexType { PositionColor }; using Position = DirectX :: XMFLOAT3 ; using Color = DirectX :: XMFLOAT3 ; struct VertexPositionColor { Position position ; Color color ; }; This file will contain all future vertex types as well. Pipeline & DeviceContext \u00b6 Pipeline \u00b6 What is a pipeline? It's just a immutable container of various things. It describes all state for the current thing you want to render or compute. All Vertex and Pixel or Compute shaders we might require for that render task to complete, the type of primitives we want to draw and how they are setup. Since we are coming from the Hello Triangle chapter our pipeline will not contain much, but it will grow in complexity further down the chapter road. PipelineFactory \u00b6 PipelineFactory will handle the creation of Pipeline for us, which includes loading and compiling shaders, figuring out the right input layout by the given vertex type, for now. DeviceContext \u00b6 DeviceContext is an abstraction over DX's native ID3D11DeviceContext, which has plenty of methods you need to call in order to get your triangles on screen. DeviceContext will know what to call specifically and handles that for you to keep the actual business logic \"clean\". Migration to Pipeline/PipelineFactory/DeviceContext \u00b6 Let's create a Pipeline.hpp and add the following #pragma once #include \"Definitions.hpp\" #include <d3d11_2.h> #include <cstdint> class Pipeline { public : friend class PipelineFactory ; friend class DeviceContext ; void SetViewport ( float left , float top , float width , float height ); private : WRL :: ComPtr < ID3D11VertexShader > _vertexShader = nullptr ; WRL :: ComPtr < ID3D11PixelShader > _pixelShader = nullptr ; WRL :: ComPtr < ID3D11InputLayout > _inputLayout = nullptr ; D3D11_PRIMITIVE_TOPOLOGY _primitiveTopology = {}; uint32_t _vertexSize = 0 ; D3D11_VIEWPORT _viewport = {}; }; Pipeline is supposed to be an immutable object, there fore all relevant fields are private , so that you cant accidentally set them from outside. Only PipelineFactory will be able to access those fields, as its creating them. Also DeviceContext can access them too, as it needs these to set the actual state/values. We also create Pipeline.cpp with the following content: #include \"Pipeline.hpp\" void Pipeline::SetViewport ( const float left , const float top , const float width , const float height ) { _viewport . TopLeftX = left ; _viewport . TopLeftY = top ; _viewport . Width = width ; _viewport . Height = height ; _viewport . MinDepth = 0.0f ; _viewport . MaxDepth = 1.0f ; } Its quite empty for now. Lets move on to PipelineFactory . Create a new file PipelineFactory.hpp and add the following content: #pragma once #include \"Definitions.hpp\" #include \"VertexType.hpp\" #include \"Pipeline.hpp\" #include <d3d11_2.h> #include <unordered_map> #include <string> #include <memory> struct PipelineDescriptor { std :: wstring VertexFilePath ; std :: wstring PixelFilePath ; VertexType VertexType ; }; class PipelineFactory { public : PipelineFactory ( const WRL :: ComPtr < ID3D11Device >& device ); bool CreatePipeline ( const PipelineDescriptor & settings , std :: unique_ptr < Pipeline >& pipeline ); private : static size_t GetLayoutByteSize ( VertexType vertexType ); [[ nodiscard ]] WRL :: ComPtr < ID3D11VertexShader > CreateVertexShader ( const std :: wstring & filePath , WRL :: ComPtr < ID3DBlob >& vertexShaderBlob ) const ; [[ nodiscard ]] WRL :: ComPtr < ID3D11PixelShader > CreatePixelShader ( const std :: wstring & filePath ) const ; bool CreateInputLayout ( VertexType layoutInfo , const WRL :: ComPtr < ID3DBlob >& vertexBlob , WRL :: ComPtr < ID3D11InputLayout >& inputLayout ); bool CompileShader ( const std :: wstring & filePath , const std :: string & entryPoint , const std :: string & profile , WRL :: ComPtr < ID3DBlob >& shaderBlob ) const ; WRL :: ComPtr < ID3D11Device > _device = nullptr ; std :: unordered_map < VertexType , std :: vector < D3D11_INPUT_ELEMENT_DESC >> _layoutMap ; }; You can remove the methods from HelloTriangleApplication.hpp and HelloTriangleApplication.cpp since we are now using a separate class. We also need PipelineFactory.cpp with the following content. size_t PipelineFactory::GetLayoutByteSize ( const VertexType vertexType ) { switch ( vertexType ) { case VertexType :: PositionColor : return sizeof ( VertexPositionColor ); } return 0 ; } PipelineFactory :: PipelineFactory ( const WRL :: ComPtr < ID3D11Device >& device ) { _device = device ; _layoutMap [ VertexType :: PositionColor ] = { { { \"POSITION\" , 0 , DXGI_FORMAT :: DXGI_FORMAT_R32G32B32_FLOAT , 0 , offsetof ( VertexPositionColor , position ), D3D11_INPUT_CLASSIFICATION :: D3D11_INPUT_PER_VERTEX_DATA , 0 }, { \"COLOR\" , 0 , DXGI_FORMAT :: DXGI_FORMAT_R32G32B32_FLOAT , 0 , offsetof ( VertexPositionColor , color ), D3D11_INPUT_CLASSIFICATION :: D3D11_INPUT_PER_VERTEX_DATA , 0 }, } }; } bool PipelineFactory :: CreatePipeline ( const PipelineDescriptor & settings , std :: unique_ptr < Pipeline >& pipeline ) { WRL :: ComPtr < ID3DBlob > vertexShaderBlob ; pipeline = std :: make_unique < Pipeline > (); pipeline -> _vertexShader = CreateVertexShader ( settings . VertexFilePath , vertexShaderBlob ); pipeline -> _pixelShader = CreatePixelShader ( settings . PixelFilePath ); if ( ! CreateInputLayout ( settings . VertexType , vertexShaderBlob , pipeline -> _inputLayout )) { return false ; } pipeline -> _primitiveTopology = D3D11_PRIMITIVE_TOPOLOGY :: D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST ; pipeline -> _vertexSize = static_cast < uint32_t > ( GetLayoutByteSize ( settings . VertexType )); return true ; } bool PipelineFactory :: CompileShader ( const std :: wstring & filePath , const std :: string & entryPoint , const std :: string & profile , WRL :: ComPtr < ID3DBlob >& shaderBlob ) const { constexpr uint32_t compileFlags = D3DCOMPILE_ENABLE_STRICTNESS ; WRL :: ComPtr < ID3DBlob > tempShaderBlob = nullptr ; WRL :: ComPtr < ID3DBlob > errorBlob = nullptr ; if ( FAILED ( D3DCompileFromFile ( filePath . data (), nullptr , D3D_COMPILE_STANDARD_FILE_INCLUDE , entryPoint . data (), profile . data (), compileFlags , 0 , & tempShaderBlob , & errorBlob ))) { std :: cout << \"D3D11: Failed to read shader from file \\n \" ; if ( errorBlob != nullptr ) { std :: cout << \"D3D11: With message: \" << static_cast < const char *> ( errorBlob -> GetBufferPointer ()) << \" \\n \" ; } return false ; } shaderBlob = std :: move ( tempShaderBlob ); return true ; } WRL :: ComPtr < ID3D11VertexShader > PipelineFactory :: CreateVertexShader ( const std :: wstring & filePath , WRL :: ComPtr < ID3DBlob >& vertexShaderBlob ) const { if ( ! CompileShader ( filePath , \"Main\" , \"vs_5_0\" , vertexShaderBlob )) { return nullptr ; } WRL :: ComPtr < ID3D11VertexShader > vertexShader ; if ( FAILED ( _device -> CreateVertexShader ( vertexShaderBlob -> GetBufferPointer (), vertexShaderBlob -> GetBufferSize (), nullptr , & vertexShader ))) { std :: cout << \"D3D11: Failed to compile vertex shader \\n \" ; return nullptr ; } return vertexShader ; } WRL :: ComPtr < ID3D11PixelShader > PipelineFactory :: CreatePixelShader ( const std :: wstring & filePath ) const { WRL :: ComPtr < ID3DBlob > pixelShaderBlob = nullptr ; if ( ! CompileShader ( filePath , \"Main\" , \"ps_5_0\" , pixelShaderBlob )) { return nullptr ; } WRL :: ComPtr < ID3D11PixelShader > pixelShader ; if ( FAILED ( _device -> CreatePixelShader ( pixelShaderBlob -> GetBufferPointer (), pixelShaderBlob -> GetBufferSize (), nullptr , & pixelShader ))) { std :: cout << \"D3D11: Failed to compile pixel shader \\n \" ; return nullptr ; } return pixelShader ; } bool PipelineFactory :: CreateInputLayout ( const VertexType layoutInfo , const WRL :: ComPtr < ID3DBlob >& vertexBlob , WRL :: ComPtr < ID3D11InputLayout >& inputLayout ) { const std :: vector < D3D11_INPUT_ELEMENT_DESC > inputLayoutDesc = _layoutMap [ layoutInfo ]; if ( FAILED ( _device -> CreateInputLayout ( inputLayoutDesc . data (), static_cast < uint32_t > ( inputLayoutDesc . size ()), vertexBlob -> GetBufferPointer (), vertexBlob -> GetBufferSize (), & inputLayout ))) { std :: cout << \"D3D11: Failed to create the input layout\" ; return false ; } return true ; } Most of the methods are now private and cannot be called from outside PipelineFactory and that is good. There is no need for somebody or something else to create arbitrary shaders or other pipeline relevant things. On to DeviceContext . Create a new DeviceContext.hpp with the following content #pragma once #include \"Definitions.hpp\" #include <d3d11_2.h> #include <cstdint> class Pipeline ; class DeviceContext { public : DeviceContext ( WRL :: ComPtr < ID3D11DeviceContext >&& deviceContext ); void Clear ( ID3D11RenderTargetView * renderTarget , float clearColor [ 4 ]) const ; void SetPipeline ( const Pipeline * pipeline ); void SetVertexBuffer ( ID3D11Buffer * triangleVertices , uint32_t vertexOffset ); void Draw () const ; void Flush () const ; private : uint32_t _drawVertices ; const Pipeline * _activePipeline ; WRL :: ComPtr < ID3D11DeviceContext > _deviceContext ; }; And its implementation file DeviceContext.cpp with the following content #include \"DeviceContext.hpp\" #include \"Pipeline.hpp\" #include <utility> DeviceContext :: DeviceContext ( WRL :: ComPtr < ID3D11DeviceContext >&& deviceContext ) { _deviceContext = std :: move ( deviceContext ); _activePipeline = nullptr ; _drawVertices = 0 ; } void DeviceContext :: Clear ( ID3D11RenderTargetView * renderTarget , float clearColor [ 4 ]) const { _deviceContext -> ClearRenderTargetView ( renderTarget , clearColor ); _deviceContext -> OMSetRenderTargets ( 1 , & renderTarget , nullptr ); } void DeviceContext :: SetPipeline ( const Pipeline * pipeline ) { _activePipeline = pipeline ; _deviceContext -> IASetInputLayout ( pipeline -> _inputLayout . Get ()); _deviceContext -> IASetPrimitiveTopology ( pipeline -> _primitiveTopology ); _deviceContext -> VSSetShader ( pipeline -> _vertexShader . Get (), nullptr , 0 ); _deviceContext -> PSSetShader ( pipeline -> _pixelShader . Get (), nullptr , 0 ); _deviceContext -> RSSetViewports ( 1 , & pipeline -> _viewport ); } void DeviceContext :: SetVertexBuffer ( ID3D11Buffer * triangleVertices , uint32_t vertexOffset ) { D3D11_BUFFER_DESC description = {}; triangleVertices -> GetDesc ( & description ); _deviceContext -> IASetVertexBuffers ( 0 , 1 , & triangleVertices , & _activePipeline -> _vertexSize , & vertexOffset ); _drawVertices = description . ByteWidth / _activePipeline -> _vertexSize ; } void DeviceContext :: Draw () const { _deviceContext -> Draw ( _drawVertices , 0 ); } void DeviceContext :: Flush () const { _deviceContext -> Flush (); } As you can see, DeviceContext will make sure all the state is set properly. Project on GitHub Next chapter","title":"Abstractions and Quality of Life improvements"},{"location":"1-introduction/1-1-getting-started/1-1-4-abstractions/#abstractions-and-quality-of-life-improvements","text":"Before we move on, we are going to change a few things. When you write software you dont always want all your code in one spot, one method or one class, but split it up and separate where it makes sense to do so. This is always a good exercise in projects which are getting a bit bigger, and this project will be getting bigger, since we have to cover a lot of things a lot of components will be involved. From now onwards we will explain everything you need to know to move forward in the usual way. What needs to be added and where, along with the explanations. We will also guide you what you have to add on top of all that. In the end we will have a cleaner structure of the whole thing, while still maintaining a way to find your self around within the project. Lets start:","title":"Abstractions and Quality of Life improvements"},{"location":"1-introduction/1-1-getting-started/1-1-4-abstractions/#comptr","text":"You might remember this class HelloTriangleApplication final : public Application { template < typename T > using ComPtr = Microsoft :: WRL :: ComPtr < T > ; public : We will move this type alias into a separate header, so that other components which rely on ComPtr (and make use of the shorter typename). Create a new file in the project and call it Definitions.hpp . It should look like this #pragma once #include <wrl/client.h> namespace WRL = Microsoft :: WRL ; And make sure you include it. Then rename the ComPtr<> locations from ComPtr < ID3D11Device > _device = nullptr ; to WRL :: ComPtr < ID3D11Device > _device = nullptr ; and all the others accordingly.","title":"ComPtr"},{"location":"1-introduction/1-1-getting-started/1-1-4-abstractions/#vertextype","text":"Next step, create a new file called VertexType.hpp and make sure to include it in HelloTriangleApplication.cpp Then move using Position = DirectX :: XMFLOAT3 ; using Color = DirectX :: XMFLOAT3 ; struct VertexPositionColor { Position position ; Color color ; }; from HelloTriangleApplication.cpp into the new VertexType.hpp Should look like #pragma once #include <DirectXMath.h> enum class VertexType { PositionColor }; using Position = DirectX :: XMFLOAT3 ; using Color = DirectX :: XMFLOAT3 ; struct VertexPositionColor { Position position ; Color color ; }; This file will contain all future vertex types as well.","title":"VertexType"},{"location":"1-introduction/1-1-getting-started/1-1-4-abstractions/#pipeline-devicecontext","text":"","title":"Pipeline &amp; DeviceContext"},{"location":"1-introduction/1-1-getting-started/1-1-4-abstractions/#pipeline","text":"What is a pipeline? It's just a immutable container of various things. It describes all state for the current thing you want to render or compute. All Vertex and Pixel or Compute shaders we might require for that render task to complete, the type of primitives we want to draw and how they are setup. Since we are coming from the Hello Triangle chapter our pipeline will not contain much, but it will grow in complexity further down the chapter road.","title":"Pipeline"},{"location":"1-introduction/1-1-getting-started/1-1-4-abstractions/#pipelinefactory","text":"PipelineFactory will handle the creation of Pipeline for us, which includes loading and compiling shaders, figuring out the right input layout by the given vertex type, for now.","title":"PipelineFactory"},{"location":"1-introduction/1-1-getting-started/1-1-4-abstractions/#devicecontext","text":"DeviceContext is an abstraction over DX's native ID3D11DeviceContext, which has plenty of methods you need to call in order to get your triangles on screen. DeviceContext will know what to call specifically and handles that for you to keep the actual business logic \"clean\".","title":"DeviceContext"},{"location":"1-introduction/1-1-getting-started/1-1-4-abstractions/#migration-to-pipelinepipelinefactorydevicecontext","text":"Let's create a Pipeline.hpp and add the following #pragma once #include \"Definitions.hpp\" #include <d3d11_2.h> #include <cstdint> class Pipeline { public : friend class PipelineFactory ; friend class DeviceContext ; void SetViewport ( float left , float top , float width , float height ); private : WRL :: ComPtr < ID3D11VertexShader > _vertexShader = nullptr ; WRL :: ComPtr < ID3D11PixelShader > _pixelShader = nullptr ; WRL :: ComPtr < ID3D11InputLayout > _inputLayout = nullptr ; D3D11_PRIMITIVE_TOPOLOGY _primitiveTopology = {}; uint32_t _vertexSize = 0 ; D3D11_VIEWPORT _viewport = {}; }; Pipeline is supposed to be an immutable object, there fore all relevant fields are private , so that you cant accidentally set them from outside. Only PipelineFactory will be able to access those fields, as its creating them. Also DeviceContext can access them too, as it needs these to set the actual state/values. We also create Pipeline.cpp with the following content: #include \"Pipeline.hpp\" void Pipeline::SetViewport ( const float left , const float top , const float width , const float height ) { _viewport . TopLeftX = left ; _viewport . TopLeftY = top ; _viewport . Width = width ; _viewport . Height = height ; _viewport . MinDepth = 0.0f ; _viewport . MaxDepth = 1.0f ; } Its quite empty for now. Lets move on to PipelineFactory . Create a new file PipelineFactory.hpp and add the following content: #pragma once #include \"Definitions.hpp\" #include \"VertexType.hpp\" #include \"Pipeline.hpp\" #include <d3d11_2.h> #include <unordered_map> #include <string> #include <memory> struct PipelineDescriptor { std :: wstring VertexFilePath ; std :: wstring PixelFilePath ; VertexType VertexType ; }; class PipelineFactory { public : PipelineFactory ( const WRL :: ComPtr < ID3D11Device >& device ); bool CreatePipeline ( const PipelineDescriptor & settings , std :: unique_ptr < Pipeline >& pipeline ); private : static size_t GetLayoutByteSize ( VertexType vertexType ); [[ nodiscard ]] WRL :: ComPtr < ID3D11VertexShader > CreateVertexShader ( const std :: wstring & filePath , WRL :: ComPtr < ID3DBlob >& vertexShaderBlob ) const ; [[ nodiscard ]] WRL :: ComPtr < ID3D11PixelShader > CreatePixelShader ( const std :: wstring & filePath ) const ; bool CreateInputLayout ( VertexType layoutInfo , const WRL :: ComPtr < ID3DBlob >& vertexBlob , WRL :: ComPtr < ID3D11InputLayout >& inputLayout ); bool CompileShader ( const std :: wstring & filePath , const std :: string & entryPoint , const std :: string & profile , WRL :: ComPtr < ID3DBlob >& shaderBlob ) const ; WRL :: ComPtr < ID3D11Device > _device = nullptr ; std :: unordered_map < VertexType , std :: vector < D3D11_INPUT_ELEMENT_DESC >> _layoutMap ; }; You can remove the methods from HelloTriangleApplication.hpp and HelloTriangleApplication.cpp since we are now using a separate class. We also need PipelineFactory.cpp with the following content. size_t PipelineFactory::GetLayoutByteSize ( const VertexType vertexType ) { switch ( vertexType ) { case VertexType :: PositionColor : return sizeof ( VertexPositionColor ); } return 0 ; } PipelineFactory :: PipelineFactory ( const WRL :: ComPtr < ID3D11Device >& device ) { _device = device ; _layoutMap [ VertexType :: PositionColor ] = { { { \"POSITION\" , 0 , DXGI_FORMAT :: DXGI_FORMAT_R32G32B32_FLOAT , 0 , offsetof ( VertexPositionColor , position ), D3D11_INPUT_CLASSIFICATION :: D3D11_INPUT_PER_VERTEX_DATA , 0 }, { \"COLOR\" , 0 , DXGI_FORMAT :: DXGI_FORMAT_R32G32B32_FLOAT , 0 , offsetof ( VertexPositionColor , color ), D3D11_INPUT_CLASSIFICATION :: D3D11_INPUT_PER_VERTEX_DATA , 0 }, } }; } bool PipelineFactory :: CreatePipeline ( const PipelineDescriptor & settings , std :: unique_ptr < Pipeline >& pipeline ) { WRL :: ComPtr < ID3DBlob > vertexShaderBlob ; pipeline = std :: make_unique < Pipeline > (); pipeline -> _vertexShader = CreateVertexShader ( settings . VertexFilePath , vertexShaderBlob ); pipeline -> _pixelShader = CreatePixelShader ( settings . PixelFilePath ); if ( ! CreateInputLayout ( settings . VertexType , vertexShaderBlob , pipeline -> _inputLayout )) { return false ; } pipeline -> _primitiveTopology = D3D11_PRIMITIVE_TOPOLOGY :: D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST ; pipeline -> _vertexSize = static_cast < uint32_t > ( GetLayoutByteSize ( settings . VertexType )); return true ; } bool PipelineFactory :: CompileShader ( const std :: wstring & filePath , const std :: string & entryPoint , const std :: string & profile , WRL :: ComPtr < ID3DBlob >& shaderBlob ) const { constexpr uint32_t compileFlags = D3DCOMPILE_ENABLE_STRICTNESS ; WRL :: ComPtr < ID3DBlob > tempShaderBlob = nullptr ; WRL :: ComPtr < ID3DBlob > errorBlob = nullptr ; if ( FAILED ( D3DCompileFromFile ( filePath . data (), nullptr , D3D_COMPILE_STANDARD_FILE_INCLUDE , entryPoint . data (), profile . data (), compileFlags , 0 , & tempShaderBlob , & errorBlob ))) { std :: cout << \"D3D11: Failed to read shader from file \\n \" ; if ( errorBlob != nullptr ) { std :: cout << \"D3D11: With message: \" << static_cast < const char *> ( errorBlob -> GetBufferPointer ()) << \" \\n \" ; } return false ; } shaderBlob = std :: move ( tempShaderBlob ); return true ; } WRL :: ComPtr < ID3D11VertexShader > PipelineFactory :: CreateVertexShader ( const std :: wstring & filePath , WRL :: ComPtr < ID3DBlob >& vertexShaderBlob ) const { if ( ! CompileShader ( filePath , \"Main\" , \"vs_5_0\" , vertexShaderBlob )) { return nullptr ; } WRL :: ComPtr < ID3D11VertexShader > vertexShader ; if ( FAILED ( _device -> CreateVertexShader ( vertexShaderBlob -> GetBufferPointer (), vertexShaderBlob -> GetBufferSize (), nullptr , & vertexShader ))) { std :: cout << \"D3D11: Failed to compile vertex shader \\n \" ; return nullptr ; } return vertexShader ; } WRL :: ComPtr < ID3D11PixelShader > PipelineFactory :: CreatePixelShader ( const std :: wstring & filePath ) const { WRL :: ComPtr < ID3DBlob > pixelShaderBlob = nullptr ; if ( ! CompileShader ( filePath , \"Main\" , \"ps_5_0\" , pixelShaderBlob )) { return nullptr ; } WRL :: ComPtr < ID3D11PixelShader > pixelShader ; if ( FAILED ( _device -> CreatePixelShader ( pixelShaderBlob -> GetBufferPointer (), pixelShaderBlob -> GetBufferSize (), nullptr , & pixelShader ))) { std :: cout << \"D3D11: Failed to compile pixel shader \\n \" ; return nullptr ; } return pixelShader ; } bool PipelineFactory :: CreateInputLayout ( const VertexType layoutInfo , const WRL :: ComPtr < ID3DBlob >& vertexBlob , WRL :: ComPtr < ID3D11InputLayout >& inputLayout ) { const std :: vector < D3D11_INPUT_ELEMENT_DESC > inputLayoutDesc = _layoutMap [ layoutInfo ]; if ( FAILED ( _device -> CreateInputLayout ( inputLayoutDesc . data (), static_cast < uint32_t > ( inputLayoutDesc . size ()), vertexBlob -> GetBufferPointer (), vertexBlob -> GetBufferSize (), & inputLayout ))) { std :: cout << \"D3D11: Failed to create the input layout\" ; return false ; } return true ; } Most of the methods are now private and cannot be called from outside PipelineFactory and that is good. There is no need for somebody or something else to create arbitrary shaders or other pipeline relevant things. On to DeviceContext . Create a new DeviceContext.hpp with the following content #pragma once #include \"Definitions.hpp\" #include <d3d11_2.h> #include <cstdint> class Pipeline ; class DeviceContext { public : DeviceContext ( WRL :: ComPtr < ID3D11DeviceContext >&& deviceContext ); void Clear ( ID3D11RenderTargetView * renderTarget , float clearColor [ 4 ]) const ; void SetPipeline ( const Pipeline * pipeline ); void SetVertexBuffer ( ID3D11Buffer * triangleVertices , uint32_t vertexOffset ); void Draw () const ; void Flush () const ; private : uint32_t _drawVertices ; const Pipeline * _activePipeline ; WRL :: ComPtr < ID3D11DeviceContext > _deviceContext ; }; And its implementation file DeviceContext.cpp with the following content #include \"DeviceContext.hpp\" #include \"Pipeline.hpp\" #include <utility> DeviceContext :: DeviceContext ( WRL :: ComPtr < ID3D11DeviceContext >&& deviceContext ) { _deviceContext = std :: move ( deviceContext ); _activePipeline = nullptr ; _drawVertices = 0 ; } void DeviceContext :: Clear ( ID3D11RenderTargetView * renderTarget , float clearColor [ 4 ]) const { _deviceContext -> ClearRenderTargetView ( renderTarget , clearColor ); _deviceContext -> OMSetRenderTargets ( 1 , & renderTarget , nullptr ); } void DeviceContext :: SetPipeline ( const Pipeline * pipeline ) { _activePipeline = pipeline ; _deviceContext -> IASetInputLayout ( pipeline -> _inputLayout . Get ()); _deviceContext -> IASetPrimitiveTopology ( pipeline -> _primitiveTopology ); _deviceContext -> VSSetShader ( pipeline -> _vertexShader . Get (), nullptr , 0 ); _deviceContext -> PSSetShader ( pipeline -> _pixelShader . Get (), nullptr , 0 ); _deviceContext -> RSSetViewports ( 1 , & pipeline -> _viewport ); } void DeviceContext :: SetVertexBuffer ( ID3D11Buffer * triangleVertices , uint32_t vertexOffset ) { D3D11_BUFFER_DESC description = {}; triangleVertices -> GetDesc ( & description ); _deviceContext -> IASetVertexBuffers ( 0 , 1 , & triangleVertices , & _activePipeline -> _vertexSize , & vertexOffset ); _drawVertices = description . ByteWidth / _activePipeline -> _vertexSize ; } void DeviceContext :: Draw () const { _deviceContext -> Draw ( _drawVertices , 0 ); } void DeviceContext :: Flush () const { _deviceContext -> Flush (); } As you can see, DeviceContext will make sure all the state is set properly. Project on GitHub Next chapter","title":"Migration to Pipeline/PipelineFactory/DeviceContext"},{"location":"1-introduction/1-2-debug/1-2-0-overview/","text":"Overview \u00b6 While developing your graphics engine, your game, or your small tool to visualize stuff, you sometimes end up in situations where you don't know what is going on, or can't explain why this dang triangle is not showing up, while the screen is black. There are various tools and techniques which can help us getting the triangle on the screen. Clear State Debug Layer Naming Things RenderDoc Laptop GPUs Next chapter","title":"Overview"},{"location":"1-introduction/1-2-debug/1-2-0-overview/#overview","text":"While developing your graphics engine, your game, or your small tool to visualize stuff, you sometimes end up in situations where you don't know what is going on, or can't explain why this dang triangle is not showing up, while the screen is black. There are various tools and techniques which can help us getting the triangle on the screen. Clear State Debug Layer Naming Things RenderDoc Laptop GPUs Next chapter","title":"Overview"},{"location":"1-introduction/1-2-debug/1-2-1-clear-state/","text":"Clear State \u00b6 The Clear State is useful to make sure no state from previous drawcalls is still being used. For example: Say we have just drawn our scene, all models and such are being drawn properly, but now we decide to add some UI, we adjust some state that normally is set-once and forget (at initialisation) like scissor rects or viewports. But now after we're done adding our UI element draw, suddenly our models are drawing in some weird square on the screen, or models that perhaps did not have a normal-map suddenly use a UI texture as if it were one. This is something that can happen if we don't have a clear state, and really only goes wrong if one did not think they'd had to set some part of the pipeline during some draws. The usefulness of a Clear State generally comes in being able to enable or disable it at will and it being used as a mechanic to spot rendering bugs caused by state that was not (re)set correctly. So as soon as weird things start to happen, you can use a clear state between say every draw, and if the bug then disappears you'll know it's very likely related to state set from a previous draw. One can accomplish this in a few ways: Setting their states/buffers/resources/targets to NULL where possible by hand. Or call a more \"reset it all\" function that exists on the ID3D11DeviceContext aptly called ClearState() . Info https://docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-clearstate Though keep in mind that using the latter function also resets stuff like the inputlayout, primitive topology and literally everything. This might require a bit more work in making sure all rendering state is setup correctly again afterwards In pure performance terms it can be quite wasteful to reset a whole bunch of state (or re-set it) every draw/pass/frame which is why this is viewed as a debugging option. In the end, one generally should make sure their draws always set (or have set) their required state so they do not need to use a clear-state. Next chapter","title":"Clear State"},{"location":"1-introduction/1-2-debug/1-2-1-clear-state/#clear-state","text":"The Clear State is useful to make sure no state from previous drawcalls is still being used. For example: Say we have just drawn our scene, all models and such are being drawn properly, but now we decide to add some UI, we adjust some state that normally is set-once and forget (at initialisation) like scissor rects or viewports. But now after we're done adding our UI element draw, suddenly our models are drawing in some weird square on the screen, or models that perhaps did not have a normal-map suddenly use a UI texture as if it were one. This is something that can happen if we don't have a clear state, and really only goes wrong if one did not think they'd had to set some part of the pipeline during some draws. The usefulness of a Clear State generally comes in being able to enable or disable it at will and it being used as a mechanic to spot rendering bugs caused by state that was not (re)set correctly. So as soon as weird things start to happen, you can use a clear state between say every draw, and if the bug then disappears you'll know it's very likely related to state set from a previous draw. One can accomplish this in a few ways: Setting their states/buffers/resources/targets to NULL where possible by hand. Or call a more \"reset it all\" function that exists on the ID3D11DeviceContext aptly called ClearState() . Info https://docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-clearstate Though keep in mind that using the latter function also resets stuff like the inputlayout, primitive topology and literally everything. This might require a bit more work in making sure all rendering state is setup correctly again afterwards In pure performance terms it can be quite wasteful to reset a whole bunch of state (or re-set it) every draw/pass/frame which is why this is viewed as a debugging option. In the end, one generally should make sure their draws always set (or have set) their required state so they do not need to use a clear-state. Next chapter","title":"Clear State"},{"location":"1-introduction/1-2-debug/1-2-2-debug-layer/","text":"Debug Layer \u00b6 During development it is important to have tools to help you. Be it pointing out typos, obvious error or simple hints why things might not draw on screen. D3D11 provides a debug layer, which can give you hints, warnings and errors when you put in the wrong values into calls for d3d11 functions. This debug layer needs to be actively enabled, which is a simple flag you have to set when creating the device. Right now we have thee deviceFlags UINT deviceFlags = D3D11_CREATE_DEVICE_FLAG :: D3D11_CREATE_DEVICE_BGRA_SUPPORT ; and change it to UINT deviceFlags = D3D11_CREATE_DEVICE_FLAG :: D3D11_CREATE_DEVICE_BGRA_SUPPORT ; #if !defined(NDEBUG) deviceFlags |= D3D11_CREATE_DEVICE_FLAG :: D3D11_CREATE_DEVICE_DEBUG ; #endif Obviously this makes sense when you are running this in the Debug configuration where the preprocessor variable DEBUG / _DEBUG is defined, or rather where when is NDEBUG is not defined :) (like it is in Release configuration). in DebugLayer.hpp we have to add the following member variable ComPtr < ID3D11Debug > _debug = nullptr ; and we initialize it in DebugLayer.cpp 's Initialize , right after we create device and device context. if ( FAILED ( _device . As ( & _debug ))) { std :: cout << \"D3D11: Failed to get the debug layer from the device \\n \" ; return false ; } and we also adjust the destructor too _deviceContext . Reset (); #if !defined(NDEBUG) _debug -> ReportLiveDeviceObjects ( D3D11_RLDO_FLAGS :: D3D11_RLDO_DETAIL ); _debug . Reset (); #endif _device . Reset (); ReportLiveDeviceObjects even tells us at the end of the application which and how many objects are still alive from our d3d11 adventure. It will help us track leaks in the future. Now try changing the following value to see the actual debug layer in action. Find swapChainDescriptor . BufferCount = 2 ; and change it to swapChainDescriptor . BufferCount = 1 ; The debug layer will yell at you, in the Console window of Visual Studio: DXGI ERROR: IDXGIFactory::CreateSwapChain: Flip model swapchains ( DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL and DXGI_SWAP_EFFECT_FLIP_DISCARD ) require BufferCount to be between 2 and DXGI_MAX_SWAP_CHAIN_BUFFERS, inclusively. DXGI_SWAP_CHAIN_DESC { SwapChainType = ..._HWND, BufferDesc = DXGI_MODE_DESC1 { Width = 3456 , Height = 1944 , RefreshRate = DXGI_RATIONAL { Numerator = 0 , Denominator = 0 } , Format = B8G8R8A8_UNORM, ScanlineOrde or find _deviceContext -> Draw ( 3 , 0 ); and change it to _deviceContext -> Draw ( 6 , 0 ); and the debug layer will tell you thats not cool (you cant draw more triangles than there are defined in the vertexbuffer/bound to the input assembly) D3D11 WARNING: ID3D11DeviceContext::Draw: Vertex Buffer at the input vertex slot 0 is not big enough for what the Draw* () call expects to traverse. This is OK, as reading off the end of the Buffer is defined to return 0 . However the developer probably did not intend to make use of this behavior. [ EXECUTION WARNING #356: DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL] Explain InfoQueue How to mute certain messages Explain InfoQueue via dxcpl How to do that via the control panel One thing which should go without saying, the debug layer will slow down your application a bit. Project on GitHub Next chapter","title":"Debug Layer"},{"location":"1-introduction/1-2-debug/1-2-2-debug-layer/#debug-layer","text":"During development it is important to have tools to help you. Be it pointing out typos, obvious error or simple hints why things might not draw on screen. D3D11 provides a debug layer, which can give you hints, warnings and errors when you put in the wrong values into calls for d3d11 functions. This debug layer needs to be actively enabled, which is a simple flag you have to set when creating the device. Right now we have thee deviceFlags UINT deviceFlags = D3D11_CREATE_DEVICE_FLAG :: D3D11_CREATE_DEVICE_BGRA_SUPPORT ; and change it to UINT deviceFlags = D3D11_CREATE_DEVICE_FLAG :: D3D11_CREATE_DEVICE_BGRA_SUPPORT ; #if !defined(NDEBUG) deviceFlags |= D3D11_CREATE_DEVICE_FLAG :: D3D11_CREATE_DEVICE_DEBUG ; #endif Obviously this makes sense when you are running this in the Debug configuration where the preprocessor variable DEBUG / _DEBUG is defined, or rather where when is NDEBUG is not defined :) (like it is in Release configuration). in DebugLayer.hpp we have to add the following member variable ComPtr < ID3D11Debug > _debug = nullptr ; and we initialize it in DebugLayer.cpp 's Initialize , right after we create device and device context. if ( FAILED ( _device . As ( & _debug ))) { std :: cout << \"D3D11: Failed to get the debug layer from the device \\n \" ; return false ; } and we also adjust the destructor too _deviceContext . Reset (); #if !defined(NDEBUG) _debug -> ReportLiveDeviceObjects ( D3D11_RLDO_FLAGS :: D3D11_RLDO_DETAIL ); _debug . Reset (); #endif _device . Reset (); ReportLiveDeviceObjects even tells us at the end of the application which and how many objects are still alive from our d3d11 adventure. It will help us track leaks in the future. Now try changing the following value to see the actual debug layer in action. Find swapChainDescriptor . BufferCount = 2 ; and change it to swapChainDescriptor . BufferCount = 1 ; The debug layer will yell at you, in the Console window of Visual Studio: DXGI ERROR: IDXGIFactory::CreateSwapChain: Flip model swapchains ( DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL and DXGI_SWAP_EFFECT_FLIP_DISCARD ) require BufferCount to be between 2 and DXGI_MAX_SWAP_CHAIN_BUFFERS, inclusively. DXGI_SWAP_CHAIN_DESC { SwapChainType = ..._HWND, BufferDesc = DXGI_MODE_DESC1 { Width = 3456 , Height = 1944 , RefreshRate = DXGI_RATIONAL { Numerator = 0 , Denominator = 0 } , Format = B8G8R8A8_UNORM, ScanlineOrde or find _deviceContext -> Draw ( 3 , 0 ); and change it to _deviceContext -> Draw ( 6 , 0 ); and the debug layer will tell you thats not cool (you cant draw more triangles than there are defined in the vertexbuffer/bound to the input assembly) D3D11 WARNING: ID3D11DeviceContext::Draw: Vertex Buffer at the input vertex slot 0 is not big enough for what the Draw* () call expects to traverse. This is OK, as reading off the end of the Buffer is defined to return 0 . However the developer probably did not intend to make use of this behavior. [ EXECUTION WARNING #356: DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL] Explain InfoQueue How to mute certain messages Explain InfoQueue via dxcpl How to do that via the control panel One thing which should go without saying, the debug layer will slow down your application a bit. Project on GitHub Next chapter","title":"Debug Layer"},{"location":"1-introduction/1-2-debug/1-2-3-naming-things/","text":"Naming things \u00b6 The debug layer might tell us possible leaks of various d3d11 related objects, the cool thing is, it can tell you exactly which object is leaking, via its name. We can give our d3d11 objects a name. Each D3D11 object (not the device itself) derives from ID3D11DeviceChild and that interface implements a method SetPrivateData which we can use to assign a name to all those objects. For that we will introduce a macro (hopefully the only one :)) template < UINT TDebugNameLength > inline void SetDebugName ( _In_ ID3D11DeviceChild * deviceResource , _In_z_ const char ( & debugName )[ TDebugNameLength ]) { deviceResource -> SetPrivateData ( WKPDID_D3DDebugObjectName , TDebugNameLength - 1 , debugName ); } And we use it like SetDebugName ( _deviceContext . Get (), \"CTX_Main\" ); Unfortunately not every object is/implements ID3D11DeviceChild so for the other things like the dxgi factory or the device itself we have to use SetPrivateData the ordinary way constexpr char factoryName [] = \"Factory1\" ; _factory -> SetPrivateData ( WKPDID_D3DDebugObjectName , sizeof ( factoryName ), factoryName ); constexpr char deviceName [] = \"DEV_Main\" ; _device -> SetPrivateData ( WKPDID_D3DDebugObjectName , sizeof ( deviceName ), deviceName ); Now run the thing again and take a look at the summary report of the debug device in the output window D3D11 WARNING: Live ID3D11Device at 0x000002214E8A1B10, Name: DEV_Main, Refcount: 3 [ STATE_CREATION WARNING #441: LIVE_DEVICE] D3D11 WARNING: Live ID3D11Context at 0x000002214E8A5B50, Name: CTX_Main, Refcount: 0 , IntRef: 1 [ STATE_CREATION WARNING #2097226: LIVE_CONTEXT] Notice anything? Exactly, they show names. Project on GitHub Next chapter","title":"Naming things"},{"location":"1-introduction/1-2-debug/1-2-3-naming-things/#naming-things","text":"The debug layer might tell us possible leaks of various d3d11 related objects, the cool thing is, it can tell you exactly which object is leaking, via its name. We can give our d3d11 objects a name. Each D3D11 object (not the device itself) derives from ID3D11DeviceChild and that interface implements a method SetPrivateData which we can use to assign a name to all those objects. For that we will introduce a macro (hopefully the only one :)) template < UINT TDebugNameLength > inline void SetDebugName ( _In_ ID3D11DeviceChild * deviceResource , _In_z_ const char ( & debugName )[ TDebugNameLength ]) { deviceResource -> SetPrivateData ( WKPDID_D3DDebugObjectName , TDebugNameLength - 1 , debugName ); } And we use it like SetDebugName ( _deviceContext . Get (), \"CTX_Main\" ); Unfortunately not every object is/implements ID3D11DeviceChild so for the other things like the dxgi factory or the device itself we have to use SetPrivateData the ordinary way constexpr char factoryName [] = \"Factory1\" ; _factory -> SetPrivateData ( WKPDID_D3DDebugObjectName , sizeof ( factoryName ), factoryName ); constexpr char deviceName [] = \"DEV_Main\" ; _device -> SetPrivateData ( WKPDID_D3DDebugObjectName , sizeof ( deviceName ), deviceName ); Now run the thing again and take a look at the summary report of the debug device in the output window D3D11 WARNING: Live ID3D11Device at 0x000002214E8A1B10, Name: DEV_Main, Refcount: 3 [ STATE_CREATION WARNING #441: LIVE_DEVICE] D3D11 WARNING: Live ID3D11Context at 0x000002214E8A5B50, Name: CTX_Main, Refcount: 0 , IntRef: 1 [ STATE_CREATION WARNING #2097226: LIVE_CONTEXT] Notice anything? Exactly, they show names. Project on GitHub Next chapter","title":"Naming things"},{"location":"1-introduction/1-2-debug/1-2-4-renderdoc/","text":"RenderDoc \u00b6 Typically while developing an application there will be complications that cannot be easily deduced by watching the program execute or by reading the code; in a situation like this one will use a debugger to monitor the state of the program to locate the bug, and this is no different for graphics programming. Graphics programmers will use what is called a \"graphics debugger\" when working with a graphics API to monitor API calls, pipeline state, data within the pipeline, etc. While there are multiple graphics debuggers provided by multiple vendors such as Nvidia's Nsight, AMD's Radeon Graphics Profiler (Does not directly support DX11), Intel's Graphics Performance Analyzers, and Microsoft's PIX, we will instead be using a cross-platform open-source option, RenderDoc. To download RenderDoc, click here and follow the instructions on the webpage. Before getting into the details of Renderdoc, an executable is needed to display what the application is capable of. In the \u201cExecutable Path\u201d navigate to the directory of the last section\u2019s project and set it as the executable. Set the \u201cWorking Directory\u201d to the directory where the asset and shader folders are kept. RenderDoc can now be started by clicking the \u201cLaunch\u201d button in the bottom right of the \u201cLaunch Application\" tab. Upon launching the application it will have an overlay in the top left corner stating the active API, frame count, frame time, captures saved, and to press F12 to take a frame capture. After a frame has been captured and the captured application is closed, return to RenderDoc. The RenderDoc window is now fully populated, however for the sake of brevity only the \u201cEvent Browser\u201d, \u201cAPI Inspector\u201d, \u201cPipeline State\u201d, and \u201cResource Inspector\u201d are of concern. The event browser displays a generalization of the API calls called in the form of events, an event is one or more API calls that have been grouped together by relation. There is not much going on in this example, but it can be helpful when debugging scenes making hundreds or even thousands of draws and dispatches a frame. The API Inspector displays the contents of an event by listing out the API calls that it contains. For example, all the calls made to set the state for the draw call are grouped together under an event called \u201cDraw\u201d. The Pipeline State tab displays the state of each active pipeline stage in addition to bound resources for the currently selected event. In this instance, the hull, domain, and geometry shader stages are grayed out because they were not used for that draw. The compute shader stage is called with its own dispatch commands and therefore is never active with the other stages; it is not a part of the rasterization pipeline. The Resource Inspector presents a list of all the resources used to render the frame on the right side of the window with information pertaining to its usage within the frame, related resources, and the functions used to initialize the resource. To learn more about RenderDoc, click here for its documentation. Next chapter","title":"RenderDoc"},{"location":"1-introduction/1-2-debug/1-2-4-renderdoc/#renderdoc","text":"Typically while developing an application there will be complications that cannot be easily deduced by watching the program execute or by reading the code; in a situation like this one will use a debugger to monitor the state of the program to locate the bug, and this is no different for graphics programming. Graphics programmers will use what is called a \"graphics debugger\" when working with a graphics API to monitor API calls, pipeline state, data within the pipeline, etc. While there are multiple graphics debuggers provided by multiple vendors such as Nvidia's Nsight, AMD's Radeon Graphics Profiler (Does not directly support DX11), Intel's Graphics Performance Analyzers, and Microsoft's PIX, we will instead be using a cross-platform open-source option, RenderDoc. To download RenderDoc, click here and follow the instructions on the webpage. Before getting into the details of Renderdoc, an executable is needed to display what the application is capable of. In the \u201cExecutable Path\u201d navigate to the directory of the last section\u2019s project and set it as the executable. Set the \u201cWorking Directory\u201d to the directory where the asset and shader folders are kept. RenderDoc can now be started by clicking the \u201cLaunch\u201d button in the bottom right of the \u201cLaunch Application\" tab. Upon launching the application it will have an overlay in the top left corner stating the active API, frame count, frame time, captures saved, and to press F12 to take a frame capture. After a frame has been captured and the captured application is closed, return to RenderDoc. The RenderDoc window is now fully populated, however for the sake of brevity only the \u201cEvent Browser\u201d, \u201cAPI Inspector\u201d, \u201cPipeline State\u201d, and \u201cResource Inspector\u201d are of concern. The event browser displays a generalization of the API calls called in the form of events, an event is one or more API calls that have been grouped together by relation. There is not much going on in this example, but it can be helpful when debugging scenes making hundreds or even thousands of draws and dispatches a frame. The API Inspector displays the contents of an event by listing out the API calls that it contains. For example, all the calls made to set the state for the draw call are grouped together under an event called \u201cDraw\u201d. The Pipeline State tab displays the state of each active pipeline stage in addition to bound resources for the currently selected event. In this instance, the hull, domain, and geometry shader stages are grayed out because they were not used for that draw. The compute shader stage is called with its own dispatch commands and therefore is never active with the other stages; it is not a part of the rasterization pipeline. The Resource Inspector presents a list of all the resources used to render the frame on the right side of the window with information pertaining to its usage within the frame, related resources, and the functions used to initialize the resource. To learn more about RenderDoc, click here for its documentation. Next chapter","title":"RenderDoc"},{"location":"1-introduction/1-2-debug/1-2-5-laptop-gpus/","text":"Laptop GPUs \u00b6 Some laptops come with dedicated graphics cards not just integrated ones. Sometimes default settings let your application only use the integrated gpu, which usually is not the best to run anything but very light games. Some games and programs have a way to select the desired graphics card, you can chose which graphics card to use via the control panel of your driver. You can also enforce the use of the dedicated graphics card per code. Thats what we are going to show here. Simply find a spot in your program and add the following code extern \"C\" { __declspec ( dllexport ) DWORD NvOptimusEnablement = 0x00000001 ; \u200b __declspec ( dllexport ) int AmdPowerXpressRequestHighPerformance = 1 ; } This will enforce graphics cards from NVIDIA and AMD to use the dedicated graphics card, when available. You can find more information here for NVIDIA and here for AMD Intel might have something similar, once they release their dedicated graphics cards for laptops. Next chapter","title":"Laptop GPUs"},{"location":"1-introduction/1-2-debug/1-2-5-laptop-gpus/#laptop-gpus","text":"Some laptops come with dedicated graphics cards not just integrated ones. Sometimes default settings let your application only use the integrated gpu, which usually is not the best to run anything but very light games. Some games and programs have a way to select the desired graphics card, you can chose which graphics card to use via the control panel of your driver. You can also enforce the use of the dedicated graphics card per code. Thats what we are going to show here. Simply find a spot in your program and add the following code extern \"C\" { __declspec ( dllexport ) DWORD NvOptimusEnablement = 0x00000001 ; \u200b __declspec ( dllexport ) int AmdPowerXpressRequestHighPerformance = 1 ; } This will enforce graphics cards from NVIDIA and AMD to use the dedicated graphics card, when available. You can find more information here for NVIDIA and here for AMD Intel might have something similar, once they release their dedicated graphics cards for laptops. Next chapter","title":"Laptop GPUs"},{"location":"1-introduction/1-3-models/1-3-0-overview/","text":"Overview \u00b6 We are about to introduce models to our little framework we have so far. Models are an essential piece of every game or graphics engine. Models also means textures and images, otherwise it gets too boring :) We will be using AssImp to load models and FreeImage to load images to create textures. Apart from that we will also be learning what a depth buffer is, why index buffers are helpful, how coordinate systems work and how we can make use of them. At the end we will also be able to roam around freely by using a camera. Loading Images Loading Meshes Dear ImGui Depth Buffer Rasterizer State Coordinate Systems Camera Next chapter","title":"Overview"},{"location":"1-introduction/1-3-models/1-3-0-overview/#overview","text":"We are about to introduce models to our little framework we have so far. Models are an essential piece of every game or graphics engine. Models also means textures and images, otherwise it gets too boring :) We will be using AssImp to load models and FreeImage to load images to create textures. Apart from that we will also be learning what a depth buffer is, why index buffers are helpful, how coordinate systems work and how we can make use of them. At the end we will also be able to roam around freely by using a camera. Loading Images Loading Meshes Dear ImGui Depth Buffer Rasterizer State Coordinate Systems Camera Next chapter","title":"Overview"},{"location":"1-introduction/1-3-models/1-3-1-image-library/","text":"Image Library \u00b6 Project on GitHub Next chapter","title":"Image Library"},{"location":"1-introduction/1-3-models/1-3-1-image-library/#image-library","text":"Project on GitHub Next chapter","title":"Image Library"},{"location":"1-introduction/1-3-models/1-3-2-loading-meshes/","text":"Loading Meshes \u00b6 Error cover assimp Error cover constant buffers Error raw model loading Error refactoring into ModelFactory Project on GitHub Next chapter","title":"Loading Meshes"},{"location":"1-introduction/1-3-models/1-3-2-loading-meshes/#loading-meshes","text":"Error cover assimp Error cover constant buffers Error raw model loading Error refactoring into ModelFactory Project on GitHub Next chapter","title":"Loading Meshes"},{"location":"1-introduction/1-3-models/1-3-3-dear-imgui/","text":"Dear ImGUI \u00b6 Project on GitHub to start off Project on GitHub Next chapter","title":"Dear ImGUI"},{"location":"1-introduction/1-3-models/1-3-3-dear-imgui/#dear-imgui","text":"Project on GitHub to start off Project on GitHub Next chapter","title":"Dear ImGUI"},{"location":"1-introduction/1-3-models/1-3-4-depth-buffer/","text":"Depth Buffer \u00b6 Project on GitHub Next chapter","title":"Depth Buffer"},{"location":"1-introduction/1-3-models/1-3-4-depth-buffer/#depth-buffer","text":"Project on GitHub Next chapter","title":"Depth Buffer"},{"location":"1-introduction/1-3-models/1-3-5-rasterizer-state/","text":"Rasterizer State \u00b6 Project on GitHub Next chapter","title":"Rasterizer State"},{"location":"1-introduction/1-3-models/1-3-5-rasterizer-state/#rasterizer-state","text":"Project on GitHub Next chapter","title":"Rasterizer State"},{"location":"1-introduction/1-3-models/1-3-6-coordinate-systems/","text":"Coordinate Systems \u00b6 Theory \u00b6 Helper functions \u00b6 Next chapter","title":"Coordinate Systems"},{"location":"1-introduction/1-3-models/1-3-6-coordinate-systems/#coordinate-systems","text":"","title":"Coordinate Systems"},{"location":"1-introduction/1-3-models/1-3-6-coordinate-systems/#theory","text":"","title":"Theory"},{"location":"1-introduction/1-3-models/1-3-6-coordinate-systems/#helper-functions","text":"Next chapter","title":"Helper functions"},{"location":"1-introduction/1-3-models/1-3-7-camera/","text":"Camera \u00b6 Project on GitHub Error link to next chapter","title":"Camera"},{"location":"1-introduction/1-3-models/1-3-7-camera/#camera","text":"Project on GitHub Error link to next chapter","title":"Camera"},{"location":"8-code/repository/","text":"Code Repository \u00b6","title":"Code Repository"},{"location":"8-code/repository/#code-repository","text":"","title":"Code Repository"}]}